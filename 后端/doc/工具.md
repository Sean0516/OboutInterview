# Nginx

### 什么是nginx

nginx 是一个web 服务器和反向代理服务器 用于HTTP HTTPS SMTP POP3 和IMAP 协议

### nginx 的特性

- 反向代理/ L7 负载均衡
- 嵌入式 Perl 解释器
- 动态二进制升级
- 可用于重新编写URL ，具有非常好的PCRE 支持

### 请解释Nginx 如果处理HTTP 请求

Nginx 使用反应器模式，主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取。 在该实例中读取到缓冲区并进行处理，单个线程可以提供数万个并发连接

### 什么是正向代理和反向代理

- 正向代理就是一个人发送一个请求直接就到达了目标的服务器
- 反方代理就是请求统一被Nginx接收，nginx反向代理服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了

### 使用反向代理服务器的优点是什么

反向代理服务器可以隐藏资源服务器的存在和特征，它充当互联网云和web 服务器之间的中间层。 这对安全方面来说是很好的。特别是使用web 托管服务时

### nginx 服务器的用途

nginx 服务器的最佳用法是在网络商部署动态HTTP 内容， 使用SCGI WSGI 应用程序服务器，用于脚本的FastCGI 处理程序。 还可以作为负载均衡器

### nginx  服务器上的master 和worker 进程分别是什么

- master 进程  ：  读取及评估配置和维持
- worker进程：  处理请求

### 是否可能讲nginx 的错误替换为502 503 错误

502 === 错误网关 

503 === 服务器超载

有可能， 需要确保 fastcgi_intercept_errors 被设置为 ON，并使用错误页面指令

Location / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errorson;error_page 502 =503/error_page.html;#…}

### 请解释  ngx_http_upstream_module  的作用是什么

ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi传递、memcached 传递和 scgi 传递指令来引用的服务器组

### 请解释什么是 C10K  问题

   C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字

### 解释 x Nginx  是否支持将请求压缩到上游

您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应

### 为什么Nginx性能这么高

因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决

### Nginx负载均衡的算法怎么实现的?策略有哪些

为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器

1. 轮询(默认)  每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统

   ```shell
   upstream backserver {
   server 192.168.0.12;
   server 192.168.0.13;
   }
   ```

2. 权重 weight 

   weight的值越大分配  到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源 .权重越高，在被访问的概率越大

   ```shell
   upstream backserver {
   server 192.168.0.12 weight=2;
   server 192.168.0.13 weight=8;
   }	
   ```

   

3. ip_hash( IP绑定)   每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题

   ```shell
   upstream backserver {
   ip_hash;
   server 192.168.0.12:88;
   server 192.168.0.13:80;
   }
   ```

4. fair(第三方插件)

   必须安装upstream_fair模块。对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配

   ```shell
   upstream backserver {
   server server1;
   server server2;
   fair;
   }
   ```

5. url_hash(第三方插件)

   必须安装Nginx的hash软件包按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率

   ```shell
   upstream backserver {
   server squid1:3128;
   server squid2:3128;
   hash $request_uri;
   hash_method crc32;
   }
   ```

### Nginx配置文件nginx.conf有哪些属性模块

```shell
worker_processes 1；              # worker进程的数量
events {                     # 事件区块开始
 worker_connections 1024；         # 每个worker进程支持的最大连接数
}                      # 事件区块结束
http {                    # HTTP区块开始
 include    mime.types；           # Nginx支持的媒体类型库文件
 default_type application/octet-stream；      # 默认的媒体类型
 sendfile    on；            # 开启高效传输模式
 keepalive_timeout 65；          # 连接超时
 server {                  # 第一个Server区块开始，表示一个独立的
虚拟主机站点
   listen    80；             # 提供服务的端口，默认80
   server_name localhost；        # 提供服务的域名主机名
   location / {              # 第一个location区块开始
     root  html；          # 站点的根目录，相当于Nginx的安装目录
     index index.html index.htm；      # 默认的首页文件，多个用空格分开
   }                 # 第一个location区块结果
   error_page  500502503504 /50x.html；     # 出现对应的http状态码时，使
用50x.html回应客户
   location = /50x.html {           # location区块开始，访问
50x.html
     root  html；               # 指定对应的站点目录为html
   }
 }
```

### Nginx怎么处理请求的

```shell
server {              # 第一个Server区块开始，表示一个独立的虚拟主机
站点
   listen    80；           # 提供服务的端口，默认80
   server_name localhost；      # 提供服务的域名主机名
   location / {            # 第一个location区块开始
     root  html；        # 站点的根目录，相当于Nginx的安装目录
     index index.html index.htm；    # 默认的首页文件，多个用空格分开
   }             # 第一个location区块结果
 } 
```

### Nginx虚拟主机怎么配置

1. 基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站

   需要建立/data/www /data/bbs目录，windows本地hosts添加虚拟机ip地址对应的域名解析；对应域名
   网站目录下新增index.html文件

   ```shell
   #当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件
    server {
      listen    80;
      server_name www.lijie.com;
      location / {
        root  data/www;
        index index.html index.htm;
      }
    }
    #当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/bbs目录下文件
    server {
      listen    80;
      server_name bbs.lijie.com;
      location / {
        root  data/bbs;
        index index.html index.htm;
      }
    }
   ```

   

2. 基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台

   ```shell
   #当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件
    server {
      listen    8080;
      server_name 8080.lijie.com;
      location / {
        root  data/www;
        index index.html index.htm;
      }
    }
    #当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080
    server {
      listen    80;
      server_name www.lijie.com;
      location / {
      proxy_pass http://127.0.0.1:8080;
          index index.html index.htm;
      }
    }
   ```

   

3. 基于ip的虚拟主机



### location的作用是什么？

location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作

```shell
#优先级1,精确匹配，根路径
 location =/ {
   return 400;
 }
 #优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写
 location ^~ /av {
   root /data/av/;
 }
 #优先级3，区分大小写的正则匹配，匹配/media*****路径
 location ~ /media {
    alias /data/static/;
 }
 #优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里
 location ~* .*\.(jpg|gif|png|js|css)$ {
   root /data/av/;
 }
 #优先7，通用匹配
 location / {
   return 403;
 }
```

### 限流怎么做的

Nginx限流就是限制用户请求速度，防止服务器受不了 限流有3种

1. 正常限制访问频率（正常流量）

   限制一个用户发送的请求，我Nginx多久接收一个请求。
   Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率

2. 突发限制访问频率（突发流量）

   限制一个用户发送的请求，我Nginx多久接收一个。
   上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？
   Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数

3. 限制并发连接数

   Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置



# Tomcat



### Tomcat  的缺省端口是多少，怎么修改

修改 conf/server.xml 下的 Connector  节点，修改 port

### tomcat  部署方式

1. 直接把web 项目放在webapps  下，tomcat 会自动将其部署
2. 在server.xml 文件上配置<Context> 节点。设置相关属性即可
3. 通过Catalina  进行配置，进入到conf/Catalina/localhost 文件下，创建一个xml 文件，该文件的名字就是站点的名字

### tomcat 容器是如何创建 servlet 类实例，用到什么原理

当容器启动时，会读取在webapps  目录下所有的web 应用中的web.xml 文件，然后对xml 进行解析。 并且读取servlet 注册信息，然后，将每个应用中注册的servlet  类都进行加载。 并通过反射的方式实例化

### tomcat如何优化



### 内存调优

内存方式的设置是在 catalina.sh 中，调整一下 JAVA_OPTS 变量即可，因为后面的启动参数会把 JAVA_OPTS 作为 JVM 的启动参数来处理

具体设置如下：
JAVA_OPTS="$JAVA_OPTS  -Xmx3550m  -Xms3550m  -Xss128k  -XX:NewRatio=4 -XX:SurvivorRatio=4"

其各项参数如下：

-Xmx3550m：设置 JVM 最大可用内存为 3550M

-Xms3550m：设置 JVM 初始内存为 3550m。此值可以设置与-Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存

-Xmn2g：设置年轻代大小为 2G。整个堆大小=年轻代大小 + 年老代大小 +持久代大小。持久代一般固定大小为 64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8

-Xss128k：设置每个线程的堆栈大小。JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成

-XX:NewRatio=4:设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代）。设置为 4，则年轻代与年老代所占比值为 1：4，年轻代占整个堆栈的 1/5

-XX:MaxPermSize=16m:设置持久代大小为 16m。
-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论

### tomcat 一个请求的完整过程

1. 请求被发送到本机端口 8080，被在那里侦听的 Coyote  HTTP/1.1Connector 获得
2. Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待来自Engine 的回应
3. Engine 获得请求路径localhost/demo/1，匹配它所拥有的所有虚拟主机 Host
4. Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host处理，因为该 Host 被定义为该 Engine 的默认主机）
5. localhost Host 获得请求/demo/1，匹配它所拥有的所有 Context
6. Host 匹配到路径为/demo 的 Context（如果匹配不到就把该请求交给路径名为”“的 Context 去处理
7. path=”/demo”的 Context 获得请求/1，在它的 mapping table 中寻找对应的 servlet
8. Context 匹配到 对应的 servlet 类
9. 构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用Servlet 的 doGet 或 doPost 方法
10. Context 把执行完了之后的 HttpServletResponse 对象返回给 Host
11. Host 把 HttpServletResponse 对象返回给 Engine
12. Engine 把 HttpServletResponse 对象返回给 Connector
13. Connector 把 HttpServletResponse 对象返回给客户 browser



# Netty

### netty 的特点

一个高性能，异步事件驱动的NIO 框架，他提供了对TCP ，UDP 和文件传输的支持，使用更高效的socket 底层。对epoll 空轮询引起的cpu 占用飙升在内部进行了处理，避免了直接使用NIO 的陷阱，简化了NIO 的处理方式

采用多种decoder / encoder 支持，对TCP 粘包和分包进行自动化处理

可以使用接受/初始线程池，提高连接效率，对重连，心跳检测的简单支持

可配置IO 线程数，TCP 参数，TCP 接受和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf 

通过引用计数器及时申请释放不再引用的对象，降低GC 频率

使用单线程串行化的方式吗，高效的Reactor 线程模型

大量使用了volitale ，使用了CAS 和原子类，线程安全类的使用，读写锁的使用。

### 多路复用 通讯方式

Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下

![image-20210806114444817](https://gitee.com/Sean0516/image/raw/master/img/image-20210806114444817.png)

客户端通信序列图如下

![image-20210806114548001](https://gitee.com/Sean0516/image/raw/master/img/image-20210806114548001.png)

Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起

1. 异步通讯 异步通讯 NIO

   由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升

2. 零拷贝（ （DIRECT BUFFERS 使用堆外直接内存 使用堆外直接内存） ）

   1. Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝
   2. Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer
   3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题

3. 内存池 （ 基于内存池的缓冲区重用机制）

   随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制



### netty 的线程模型 

netty 通过Reactor 模型，基于多路复用接收器接收并处理用户请求， 内部实现了两个线程池

boss 线程池和work 线程池。其中boss 线程池的线程负责处理请求的accept 事件，当接受到accept 事件的请求时，把对应的socket 封装到一个NioSocketChannel 中，并交给work 线程，其中work 线程池负责请求的read 和write 事件 ，由对应的handler 处理

######  单线程模型

所有的I/O操作都由一个线程完成。即多路复用，事件分发和处理都在一个Reactor 线程完成，既要接受客户端的连接请求，向服务端发起连接，又要发送/读取请求或应当/响应消息。 一个NIO 线程同时处理成百上千的链路，性能上无法支持，速度慢，若线程进入死循环，整个程序不可用，对高负载，大并发的应用场景不适合

###### 多线程模型 

有一个NIO 线程只负责监听服务端，接收客户端的TCP连接请求。 NIO 线程池负责网络IO 的操作， 即数据的读取，解码，编码和发送。 一个NIO 线程可以同时处理N 条链路，但是一个链路只对应一个NIO 线程，这是为了防止发生并发操作问题。 但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题

###### 主从多线程模型  

Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写操作，从而保证main Reactor 只负责认证，握手等操作

### TCP 粘包/ 拆包的原因及解决方法

TCP 是以流的方式来处理数据，一个完整的包可能会被TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。

###### TCP/ 粘包/分包的原因

应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将发生粘包现象

###### 解决方法

消息定长： FixedLengthFrameDecoder 类

包尾增加特殊字符分割： 行分隔符类  LineBaseFrameDecoder 或者自定义分隔符类。 DelimiterBaseFrameDecoder 

将消息分割消息头和消息体  LengthFieldBaseFrameDecoder 类，分为有头部的拆包和粘包，长度字段在前且有头部的拆包和粘包，多扩展头部的拆包与粘包

### Netty 的零拷贝实现

Netty 的接受和发送ByteBuffer 采用DIRECT BUFFERS 。 使用堆外直接内存进行socket 读写，不需要进行字节缓冲区的二次拷贝，堆内存多了一个内存拷贝，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入Socket 中，ByteBuffer 由 ChannelConfig  分配， 而ChannelConfig 创建ByteBufAllocator 默认使用Direct Buffer 

CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。addComponents 方法将  header与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在 CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体

通过 FileRegion 包装的 FileChannel.tranferTo 方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题

通过  wrap 方法,  我们可以将  byte[]  数组、ByteBuf、ByteBuffer 等包装成一个  NettyByteBuf 对象, 进而避免了拷贝操作

### Netty 的高性能表现在哪些方面

1. 心跳  

   对服务端：会定时清除闲置会话 inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中 idleStateHandler 类 用来检测会话状态

2. 串行无锁化设计

   即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，并程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，
   这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优

3. 可靠性，链路有效性检测

   链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf 的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作

4. 安全性

   SSL V2 和 V3，TLS，SSL 单向认证、双向认证和第三方 CA认证

5. 高效并发编程的体现

   volatile 的大量、正确使用；CAS 和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO 通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）

6. 流量整型的作用

   防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题

# Linux  相关

### 查看日志

###### tail 

命令格式: tail  参数 文件
-f 循环读取
-q 不显示处理信息

0-v 显示详细的处理信息
-c<数目> 显示的字节数
-n<行数> 显示行数
-q, --quiet, --silent 从不输出给出文件名的首部
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒

###### head 跟tail是相反的head是看前多少行日志

###### cat

cat 是由第一行到最后一行连续显示在屏幕上

###### more

more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。more命令从前向后读取文件，因此在启动时就加载整个文件。该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）

Enter 向下n行，需要定义，默认为1行
Ctrl f 向下滚动一屏
空格键 向下滚动一屏
Ctrl b 返回上一屏
= 输出当前行的行号
:f 输出文件名和当前行的行号
v 调用vi编辑器
!命令 调用Shell，并执行命令
q退出more

###### sed

这个命令可以查找日志文件特定的一段 , 根据时间的一个范围查询，可以按照行号和时间范围查询按照行号

### Linux 中进程有哪几种状态？

1. 不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指进程不响应异步信号。
2. 暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。
3. 就绪状态：在 run_queue 队列里的状态
4. 运行状态：在 run_queue 队列里的状态
5. 可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待socket 连接、等待信号量），而被挂起
6. zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉
7. 退出状态

### 在 ps 显示出来的信息中分别用什么符号表示的

D 不可中断 Uninterruptible（usually IO）
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核 2.6 开始无效）
X 死掉的进程

### 使用什么命令查看后台任务

job -l

### 搜索文件用什么命令

find <指定目录> <指定条件> <指定动作>
whereis 加参数与文件名
locate 只加文件名
find 直接搜索磁盘，较慢。
find / -name "string*"

### 查看磁盘使用空间

df -hl

### du 和 df 的定义，以及区别

du 显示目录或文件的大小
df 显示每个<文件>所在的文件系统的信息，默认是显示所有文件系统。（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df命令则查看文件系统的磁盘分配图并考虑Meta Data。
df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况

### 给命令绑定一个宏或者按键的时候，应该怎么做呢

可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。
在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。
比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V,然后按下 F12 .我们就可
以得到 F12 的字符序列 ^[[24~。
接着使用 bind 进行绑定

### 你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢

使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除

### bash shell 中的 hash 命令有什么作用

linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径,用该命令可以打印出你所使用过的命令以及执行的次数

### 怎样一页一页地查看一个大文件的内容呢

通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要 

cat file_name.txt | more

### 怎样查看一个 linux 命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢

使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis zcat 去查看‘zcat’的介绍以及使用简要

### cd 

```shell
cd / #表示进入系统根目录
cd usr/ #表示进入当前目录下的usr目录
cd local/ #表示进入当前目录下的local目录
cd ./bin #表示进入当前目录下的bin目录
cd .. #表示进入当前目录的上一级目录
cd ../.. #表示进入当前目录的上级目录的上一级目录
cd /usr/local/bin #进入/usr/local/bin目录
cd ../etc #表示进入和当前目录同级的etc目录 #..表示当前目录的上一级目录 ../etc表示当前目录
上级目录下的etc目录（和当前目录同级）
cd ~ #表示进入当前用户的根目录（cd ~ 和直接执行cd后不加目录的效果相同）
#例如：root用户进入/root目录，bow用户进入/home/bow目录
cd ~/data #表示进入当前用户根目录下的data目录 例如：root用户则进入了/root/data目录
cd - #进入上一次的目录
```



### 》和>>命令

和>>:输出符号，将内容输出到文件中，>表示覆盖(会删除原文件内容) >>表示追加

### vim  

##### 非编辑模式命令

```shell
yy：复制光标当前行
p：粘贴
dd:删除光标当前行
$:光标跳到当前行的行尾
^:光标跳到当前行的行首
:s/原字符串/新字符串/:替换光标当前行内容
:%s/原字符串/新字符串/g:全文替换 #g表示global i表示ignore忽略大小写
/要查找的内容:从光标当前行向后查找内容
/d #在文件中查找d字母
?要查找的内容：从光标当前位置向前查找内容
?d #查找文件中的d字母
CTRL+F:向下翻1页
CTRL+B:向上翻1页
:set nu：显示文件的行号
:set nonu: 去掉行号显示
u:撤消
**:set ff :显示文件的格式 #unix表示在unix上的文件 dos表示文件是windows上的文件**
:w ：表示保存文件
:q :表示退出vim命令
:wq:保存并退出
:w!:强制保存
:q!:强制退出但不保存
:wq!:强制保存并退出
i:表示进入编辑模式，并且光标在当前行
o：表示进入编辑模式，并且光标出现的当前行的下一行(新行)
```



### 用户和权限命令

groupadd 用户组名称 #创建一个用户组

useradd 用户名 [-g 用户组名 -G 用户组名] #创建一个用户,-g指定用户的主用户组,-G指定用户的其他用户组

userdel 用户名 #删除用户

passwd 用户名 #修改用户密码

### 了解性能命令

who命令 #查询系统中的用户(登陆的用户)
whoami命令 #查看系统当前用户名
whereis命令 #查看系统安装的某个软件的路径
whereis python #查看python的安装路径
which 命令 #查找软件的可执行文件路径
which python #查看python可执行文件路径

### 压缩命令

zip 压缩文件名 要压缩的文件路径

```shell
zip 2.zip 2.txt #将2.txt压缩到2.zip中
```

unzip 压缩文件路径

```shell
unzip 2.zip #将2.zip压缩包解压到当前目录下
```

压缩.tar包

```shell
tar cvf 压缩文件名 要压缩的文件或目录
tar cvf 2.tar 2.txt #将2.txt压缩为2.tar包
```

tar xvf 压缩文件名 [-C 指定解压目录]

```shell
tar xvf 2.tar #将2.tar解压到当前目录
```


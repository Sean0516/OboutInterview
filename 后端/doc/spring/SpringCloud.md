




![image-20211108205935338](https://gitee.com/Sean0516/image/raw/master/img/image-20211108205935338.png)



### spring cloud 的核心组件有哪些

- 服务注册于发现 --- Eureka  Nacos  Zookeeper Consul
- 负载均衡（从一个服务的多台机器中选择一台 ） Ribbon  LoadBalancer 
- 服务调用 （基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求）Feign OpenFeign
- 服务熔断降级（提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题） Hystrix , Resilience4j  , alibaba sentinel 
- 服务网关  Zuul  gateWay
- 配置中心  Config  Apollo  Nacos 
- 链路追踪   sleuth   
- 服务总线  bus   nacos 



### 什么是服务雪崩，什么是服务限流

1. 当服务A 调用服务B ，服务B 调用C ，此时大量请求突然请求服务A ，假如服务A 本身可以抗住这些请求，但是如果服务C 扛不住，导致服务C 请求堆积，从而服务B 请求堆积。 从而服务A 不可用，这就是服务雪崩。 解决方式是服务降级和服务熔断
2. 服务限流是指高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮。



### 什么是服务熔断？什么是服务降级

熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制

服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强

熔断是下游服务故障触发的，降级是为了降低系统负载

## Erueka 

### Erueka 注册中心

#### Eureka 服务端

​		也称为注册中心，同其他服务注册中心一样， 支持高可用配置 。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中其他分片会把它们的状态再次同步回来

#### Eureka 客户端

​	主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端想注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态



### Eureka关键源码解读

#### getServiceUrlsFromConfig

#### 服务注册和续约

### 用zookeeper 和eureka 做注册中心有什么区别

zookeeper 保证的是CP （一致性，容错性） 而eureka  则是AP （可用性和容错性）

### 注册中心挂了，或者服务挂了，应该如何处理

注册中心挂了，可以读取本地持久化里的配置

服务挂了 ，应该存在监控中心。 

## Ribbon

### Ribbon 负载均衡

提供负载均衡，有多种负载均衡策略可供选择, 配和服务发现和断路器使用

Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到服务均衡的作用。
当Ribbon和Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来去定服务端是否已经启动

在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端的清单来自于服务注册中心（比如Eureka）。在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。
通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：

1. 服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心
2. 服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用

### Ribbon 负载均衡原理

1. Ribbon 通过ILoadBalance 接口对外提供统一的选择服务器的功能，此接口会根据不同的负载均衡策略 IRole 选择合适的Server 返回给使用者
2. IRole 是负载均衡策略的接口  ILoadBalance 通过调用IRole  的choose 方法返回server
3. IPing 用来检测Server 是否可用。 ILoadBalancer 的实现类，维护了一个Timer  每个10 s 检测一次Server 的可用状态
4. IClientConfig 主要定义了用于初始化客户端和负载均衡器的配置信息

### Ribbon 原理

负载均衡包括两个部分：负载均衡器和负载均衡策略。负载均衡器可以进一步过滤服务实例清单中不可用或者高负载的服务，排除它们。策略是最终决定选择服务的方法

#### 负载均衡器

1. IloadBalancer的源码
2. BaseLoadBalancer的源码
3. ZoneAwareLoadBalancer的chooseServer方法的源码

#### 负载均衡策略 

Ribbon提供的多种负载均衡策略，其中ZoneAvoidanceRule策略是其默认的选择策略，在存在Zone概念且Zone数量大于1的时候，它会先过滤那些负载大的服务或者有故障的服务。RoundRobinRule策略是轮询策略，也经常在没有Zone或者Zone判定失败的时候使用，它是现实中使用最多的策略

1. BestAvailableRule
2. AvilabilityFilteringRule
3. ResponseTimeWeightedRule
4. WeightedResponseTimeRule
5. RetryRule
6. RoundRibonRule
7. RandonRule
8. ZoneAvoidanceRule

## Hystrix

### 什么是 Hystrix

Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作 。提供线程池不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务器雪崩的问题 
Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能
Hystrix使用舱壁模式实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务

Hystrix 通过Spring AOP 来实现

### Hystrix 的实现原理

正常情况下，断路器关闭，服务消费者请求正常的微服务

一段时间内，失败率达到了一定阈值，断路器将打开，此时不再请求服务提供者，而是返回快速失败方法

断路器打开一段时间后，自动进入半开状态，此时，断路器运行一个请求方法提供者，如果请求调用成功，则关闭断路器 ，否则继续保持断路器打开状态

### 断路器

当命令查询没有缓存的时候，依据图5-9，流程会到达断路器。应该说断路器是Hystrix的核心内容，首先需要清楚的是，在Hystrix中，断路器有3种状态

- CLOSED：关闭
- OPEN：打开。
- HALF_OPEN：半打开

这3种状态存在下面3种可能性

- 倘若断路器状态为OPEN，那么它就会进入第⑧步，直接转到降级方法（fallback）中去
- 倘若断路器状态为CLOSE，那么它就会到第⑤步，继续执行相关的正常逻辑
- 倘若断路器状态为HALF_OPEN，那么它就会再次尝试请求，具体情况后文会再讨论

开始的时候，断路器的状态为CLOSED，也就是关闭状态，这时候我们可以很通畅地执行服务调用。但是，在一定的情况下，断路器的状态会发生变化

- CLOSED状态转换为OPEN状态：但是观察者（Observable）在观察满足一定的条件后，就会通过subscribeToStream方法获取统计分析的数据，用来判断是否转变状态。例如，当发生错误的请求占比达到50%时，就会将断路器状态从CLOSED转变为OPEN
- OPEN和HALF_OPEN的状态转换：之前我们谈到状态转变为了OPEN，此时就会阻隔请求，但是我们也要考虑恢复的问题，毕竟有时候是负荷太大才导致断路的，但是过段时间负荷可能就没有那么大了，就应该考虑恢复了。所以在当断路器打开超过一定时间（默认为5秒）的情况下，它就会进入HALF_OPEN状态，此时可以进行尝试请求，调用attemptExecution方法。但是此调用可能成功，也可能失败，如果成功，则重新将断路器设置为CLOSED状态，放行其他请求；如果不成功，则使用markNonSuccess方法，让断路器的状态继续为OPEN，阻断请求



### Hystrix 命令 

HystrixCommand和HystrixObservableCommand，通过它们就可以封装一个Hystrix命令了。其中HystrixCommand是同步请求命令，HystrixObservableCommand是异步请求命令，它们俩使用的都是流的概念，它们的底层实现是RxJava

这里Hystrix会把服务消费者的请求封装成一个HystrixCommand对象或者一个HystrixObservable Command对象，从而使你可以用不同的请求对客户进行参数化，这便是一种命令模式，能达到对“行为请求者”和“行为实现者”解耦的目的。

下面是行Hystrix命令的4种方式

1. execute()：该方法是阻塞的，从依赖请求中接收单个响应（或者出错时抛出异常）
2. queue()：从依赖请求中返回一个包含单个响应的Future对象。
3. observe()：订阅一个从依赖请求中返回的代表响应的Observable对象
4. toObservable()：返回一个Observable对象，只有当你订阅它时，它才会执行Hystrix命令并发射响应。

### 舱壁模式

舱壁模式的调用，将服务调用隔离到了各自的线程池内，它们的调用命令都是在各自的线程池内进行的了。虽然产品服务调用增多时，可能会出现大量的线程阻塞，导致其自身服务调用卡顿，甚至抛弃请求，但是它影响的将只是线程池1，而不会影响到线程池2 . 使用了舱壁模式后，我们能得到很多好处，程序也能变得更健壮，不会造成因为某个依赖服务调度压力变大而使其他调用难以进行的情况，而且我们还可以只针对某个线程池进行维护

### 请求合并

请求合并是Hystrix中除了请求缓存之外的另外一个提高性能的利器。我们之前谈过，通过HTTP协议进行REST调用，实际是一种比较消耗资源的方式。在Hystrix的调用中，它如果正常调用，最终就会通过舱壁模式进入到一个单独的线程池里。当出现高并发场景的时候，这些请求会充满线程池，导致大量的线程挂起，最终导致排队、延迟响应或者超时等现象。为了解决这些问题，Hystrix提供了请求合并的功能，也就是说，在一个很短的时间戳内，按照一定的规则进行判断，如果觉得是同样的请求，就将其合并为同一个请求，只用一条线程进行请求，然后响应多个请求。请注意，这里请求合并的作用域可以是全局性有效的（GLOBAL），也可以是单次请求有效（REQUEST）的，当然，默认情况是单次请求有效。Hystrix中提供的合并请求类是HystrixCollapser，它是一个抽象类

## Netflix Feign

### 什么是 Netflix Feign？它的优点是什么

​	基于动态代理机制，根据注解和选择的机器，拼接请求URL 地址，发起请求  Feign 的关键机制是使用了动态代理

1. 首先，对某个接口定义了@FeignClient 注解 Feign 就会正对这个接口创建一个动态代理
2. 接着调用接口的时候，本质就是调用Fegin创建的动态代理
3. Feign 的动态代理会根据接口上的@RequestMapping 等注解，来动态构造要请求的服务地址
4. 针对这个地址,发起请求，解析响应

## Zull

### 什么是zull 

Netflix Zuul是一个API网关，它的主要功能是提供网关服务。Netflix网站的超大数量和多样性，有时会导致生产中产生各种各样的问题，因为这些问题暴露得特别快，并且无任何警告，所以排错工作异常艰难，为了解决这些问题，需要有一个能够快速改变行为的系统，于是便有了Netflix Zuul。Netflix Zuul提供了一系列不同类型的过滤器（Filter），通过这些过滤器，系统维护人员能够快速灵活地过滤服务、限制流量、实现服务器的负载均衡，从而避免外部请求冲垮微服务系统（注意：断路器主要是内部服务调用并非外部请求）。Netflix Zuul提供的过滤器存在以下功能

- 身份验证  通过身份验证区分不同的权限
- 检验和安全：对请求的有效性进行验证，如短时间多次刷请求的恶意攻击、提供验证码等
- 限流  在高并发的场景下，限制请求通过的流量，避免过大的流量压垮源服务器
- 动态路由  根据需要将请求动态路由到不同的后端微服务
- 压力测试  通过增删后端微服务实例，来确定整体服务承担的流量
- 静态响应处理   对于处于高负荷的系统，提供静态资源作为服务的响应结果 （服务降级）
- 多区域弹性：类似亚马逊服务站（AWS），将请求路由到最近的服务站点，提高服务的性能

### Zuul 原理 -- 过滤器

Zuul的原理并非十分复杂，相反的，可能还算比较简单，它的本质就是一套Servlet的API。其中ZuulServlet是核心Servlet，它将接收各类请求。此外NetflixZuul还提供了ZuulServletFilter，它是一个拦截器，可以拦截各类请求。ZuulServlet和ZuulServletFilter就是Zuul的核心内容。为了更加方便地增加和删除拦截逻辑，在ZuulServlet和ZuulServletFilter的基础上，Netflix Zuul定义了自己的过滤器——ZuulFilter

当我们继承ZuulFilter后，需要实现这4个方法，而系统中已经提供了许多ZuulFilter的实现类，它们已经实现了这4个抽象方法。下面我们来了解这4个方法的作用

- shouldFilter：是否执行过滤器逻辑，也就是可以根据上下文判定是否采用过滤器拦截请求。
- run：过滤器的具体逻辑，它是过滤器的核心方法，将返回一个Object对象，倘若返回为null，则表示继续后续的正常逻辑。
- filterType：过滤器类型，有4种类型可设置：“pre”“route”“post”和“error”。
- filterOrder：设置过滤器的顺序

 filterType方法返回的字符串代表的是过滤类型，该类型是以源服务器进行区分的。按其定义分为4种

- pre：在路由到源服务器前执行的逻辑，如鉴权、选择具体的源服务器节点和参数处理等，都可以在这里实现。

- route：执行路由到源服务器的逻辑，如之前我们谈到的Apache HttpClient或者Netflix Ribbon，当前也支持OKHttp。

- post：在路由到源服务器后执行的过滤器，常见的用法是把标准的HTTP响应头添加到响应中，此外也可以通过它来收集响应的度量数据，统计成功率，还可以对源服务器请求返回的数据再次加工，然后返回到客户端，等等。

- error：倘若在整个路由源服务器的执行的过程中发生异常，就可以进入此类过滤器，它可以做全局的响应逻辑处理错误

Zuul会将多个过滤器组织为一个责任链，那么各个过滤器会以什么顺序组织呢？这是由filterOrder方法决定的，它是返回一个数字，该数字越小，在过滤器链中就越优先执行

### 自定义Zuul 过滤器开发

自定义Zuul 过滤器， 主要需要设置过滤类型，以及顺序，和判断那些需要执行过滤器逻辑。 同时，根据实际业务场景写过滤器逻辑

网关主要作用有两个，一个是接收和转发请求，而不是业务处理，负载的业务逻辑应该放在具体的资源服务器里面，另一个是保证性能，作为保护源服务器的管卡，应该能快速判定请求的时效性。同时，把一些常用的判定规则数据转载在redis 中，通过过滤器快速判断请求的有效性，就能把很多恶意请求和无效请求过滤掉，从而保护资源服务器。 当然，保护资源服务器的常用方法还有限流算法。 

### Zuul  限流 

使用 Resilience4j限速器（RateLimiter）进行限速

通过重写ZuulFilter 进行访问限流



## Config 

### Config  配置中心是如何实现自动刷新的

1. 配置中心server 端承担起配置刷新的职责
2. 提交配置触发post 请求 给server 端的bus/refresh 接口
3. server 端接收到请求并发送给spring  cloud  bus 总线
4. spring cloud bus 接收到消息并通知给其他连接到总线的客户端
5. 其他客户端接收到通知，请求server 端最新配置
6. 全部客户端均获取到最新配置

### 配置中心是如何保证数据安全的

1. 保证容器文件访问的安全性，保证所有的网络资源请求都需要登录
2. 将配置中心里面所有的配置文件中的密码进行加密，保证其密文性
3. 开发环境禁止拉去生产环境的配置文件

### SpringCloud 和 Dubbo 有哪些区别

首先，他们都是分布式管理框架。

1. dubbo 是二进制传输，占用带宽会少一点。SpringCloud是http 传输，带宽会多一点，同时使用http协议一般会使用JSON报文，消耗会更大
2. dubbo 开发难度较大，所依赖的 jar 包有很多问题大型工程无法解决。SpringCloud 对第三方的继承可以一键式生成，天然集成
3. SpringCloud 接口协议约定比较松散，需要强有力的行政措施来限制接口无序升级
4. 最大的区别: Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式



### 什么是 Spring Cloud Bus

spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件



## Spring Cloud Gateway

### 什么是gateway

Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用

### GateWay 的执行方式

1. 创建一条线程，通过类似Zuul的过滤器拦截请求
2. 对资源服务器转发请求，但注意，Gateway 并不会等待请求调用服务器器的过程，而是将处理线程挂起，这样便不再占用资源了
3. 等资源服务器返回消息后，再通过寻址的方式来响应之前客户端发送的请求



这里需要注意的有两点。

1. 因为Gateway依赖WebFlux，而WebFlux和Spring Web MVC的包冲突，所以项目再引入spring- boot-starter-web就会发生异常。
2. 其次，当前Gateway只能支持Netty容器，不支持其他容器，所以引入Tomcat或者Jetty等容器就会在运行期间出现意想不到的问题

以在pom.xml中应该删除对spring-boot-starter-web和其他容器的依赖包。如果你创建模块时不小心选择了WAR打包方式，那么还需要删除IDE为你创建的ServletInitializer.java文件，这是一个被扫描的类，是依赖Servlet容器的，而这里使用的是Netty容器，没有Servlet容器，所以它的存在会引发错误。



### Gateway 的执行原理

#### 路由（route）

路由网关是一个最基本的组件，它由ID、目标URI、断言集合和过滤器集合共同组成，当断言判定为true时，才会匹配到路由

#### 断言（predicate）

它主要是判定当前请求如何匹配路由，采用的是Java 8断言。可以存在多个断言，每个断言的入参都是Spring框架的ServerWebExchange对象类型。它允许开发者匹配来自HTTP请求的任何内容，例如URL、请求头或请求参数，当这些断言都返回true时，才执行这个路由

#### 过滤器（filter）

这些是使用特定工厂构造的SpringFrameworkGatewayFilter实例，作用是在发送下游请求之前或者之后，修改请求和响应。和断言一样，过滤器也可以有多个



### 过滤器

如果说断言（Predicate）是为了路由的匹配，那么过滤器则是在请求源服务器之前或者之后对HTTP请求和响应的拦截，以便对请求和响应做出相应的修改，如请求头和响应头的修改。为了做到这点，Gateway提供了对应的过滤器（Filter)



Gateway的过滤器分为全局过滤器和局部过滤器。全局过滤器针对所有路由有效，而局部过滤器则只针对某些路由有效。全局过滤器需要实现GlobalFilter接口，而局部过滤器则要实现GatewayFilter接口



### Ribbon和Feign的区别

1. Ribbon都是调用其他服务的，但方式不同
2. 启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients
3. 服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明
4. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可

# Spring Cloud Alibaba


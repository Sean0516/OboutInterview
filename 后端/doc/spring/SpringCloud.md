### 分布式环境下全局唯一的发号器

1. UUID  

   常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一

   ###### 优点

   1. 简单，代码方便
   2. 生成ID性能非常好，基本不会有性能问题
   3. 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对

   ###### 缺点

   1. 没有排序，无法保证趋势递增
   2. UUID往往是使用字符串存储，查询的效率比较低
   3. 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题
   4. 传输数据量大
   5. 不可读

2. 数据库自增ID 或字段

   最常见的方式。利用数据库，全数据库唯一

   ###### 优点

   1. 简单，代码方便，性能可以接受。
   2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

   ###### 缺点

   1. 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理
   2. 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。
   3. 在性能达不到要求的情况下，比较难于扩展
   4. 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。
   5. 分表分库的时候会有麻烦

   ###### 优化方案

   针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载

3. Redis生成ID

   当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现

   可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为

   另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加

   ###### 优点

   1. 不依赖于数据库，灵活方便，且性能优于数据库
   2. 数字ID天然排序，对分页或者需要排序的结果很有帮助

   ###### 缺点

   1. 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度
   2. 需要编码和配置的工作量比较大。

4. Twitter的snowflake算法

   snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID

   1. 符号位 占用 1位
   2. 时间戳 41 bit  - 41位的长度可以使用69年
   3. 机器编号 10 bit  （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点
   4.  序列号 12 bit  - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号

   ![image-20210812171442228](https://gitee.com/Sean0516/image/raw/master/img/image-20210812171442228.png)

   算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求

    snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数

   ###### 优点

   1. 不依赖于数据库，灵活方便，且性能优于数据库
   2. ID按照时间在单机上是递增的

   ###### 缺点

   1. 在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况





### 分布式锁有哪些解决方案

1. redis 分布式锁 。 通过 setnx  设置key ,value  （key 需要设置过期时间， 主要是为了解决程序失效 的问题。） 删除 key 的时候，需要删除属于自己的锁的key (判断当前key 的值和当前线程一致)  使用 watch dog  来实现锁的过期时间更新

2. 基于 zookeeper  ，基于临时节点。 顺序节点

   ![image-20211109213948639](https://gitee.com/Sean0516/image/raw/master/img/image-20211109213948639.png)

3. 基于数据库  主键或者唯一索引的唯一性 

### zookeeper  和redis  做分布式锁的区别

Redis  ：

1. redis  只保证最终一致性， 副本间的数据复制是异步进行 （Redis 集群一般是读写分离架构，存在主从同步延迟情况） 主从切换之后，可能有部分数据没有复制过去，可能会出现 锁丢失的情况 ，因此，在强一致性要求的业务不推荐使用redis ，推荐使用zk
2. redis  集群各个方法的响应时间最低

zookeeper  

1. 使用zookeeper 集群， 可能会导致session 超时时导致锁被错误释放，因此zookeeper 也无法保证完全一致性
2. zookeeper 有较好的稳定性，响应时间抖动小，没有出现异常，但是随着并发量和业务数量提升，其响应时间和QPS 会明显下降

总结

1. zookeeper 每次进行锁操作前都要创建若干节点，完成后要释放节点，会浪费很多时间
2. redis  只是简单的数据操作，没有这个问题

### 常见的限流算法

### 计数器法

计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说
明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置counter

这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题

#### 滑动窗口

滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。如果学过TCP网络协议的话，那么一定对滑动窗口这个名词不会陌生。下面这张图，很好地解释了滑动窗口算法

![image-20210810210930993](https://gitee.com/Sean0516/image/raw/master/img/image-20210810210930993.png)

在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么
0:30~0:39对应的counter就会加1

计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，所以只有1格。由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

#### 漏桶算法

![image-20210810211026116](https://gitee.com/Sean0516/image/raw/master/img/image-20210810211026116.png)

从图中我们可以看到，整个算法其实十分简单。首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多 少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。我们将算法中的水换成实际应用中的请求，我们可以看到漏桶算法天生就限制了请求的速度。当使用了漏桶算法，我们可以保证接口会以一个常速速率来处理请求。所以漏桶算法天生不会出现临界问题

#### 令牌桶算法

![image-20210810211114037](https://gitee.com/Sean0516/image/raw/master/img/image-20210810211114037.png)

从图中我们可以看到，令牌桶算法比漏桶算法稍显复杂。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以 一个固定的速率r往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通 过

#### 计数器 VS 滑动窗口

计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。

#### 漏桶算法 VS 令牌桶算法

漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过

令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法




![image-20211108205935338](https://gitee.com/Sean0516/image/raw/master/img/image-20211108205935338.png)



### 什么是 Hystrix？它如何实现容错

Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作

### 什么是 Netflix Feign？它的优点是什么



### 什么是 Spring Cloud Bus

spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件

### 什么是服务雪崩，什么是服务限流i

1. 当服务A 调用服务B ，服务B 调用C ，此时大量请求突然请求服务A ，加入服务A 本身可以抗住这些请求，但是如果服务C 扛不住，导致服务C 请求堆积，从而服务B 请求堆积。 从而服务A 不可用，这就是服务雪崩。 解决方式是服务降级和服务熔断
2. 服务限流是指高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮。



### 什么是服务熔断？什么是服务降级

熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制

服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强

熔断是下游服务故障触发的，降级是为了降低系统负载





### Spring Cloud Gateway

Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用

### spring cloud 的核心组件有哪些

- Eureka：服务注册于发现
- Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求
- Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
- Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
- Zuul：网关管理，由 Zuul 网关转发请求给对应的服务

### SpringCloud 和 Dubbo 有哪些区别

首先，他们都是分布式管理框架。

1. dubbo 是二进制传输，占用带宽会少一点。SpringCloud是http 传输，带宽会多一点，同时使用http协议一般会使用JSON报文，消耗会更大
2. dubbo 开发难度较大，所依赖的 jar 包有很多问题大型工程无法解决。SpringCloud 对第三方的继承可以一键式生成，天然集成
3. SpringCloud 接口协议约定比较松散，需要强有力的行政措施来限制接口无序升级
4. 最大的区别: Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式

### Ribbon和Feign的区别

1. Ribbon都是调用其他服务的，但方式不同
2. 启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients
3. 服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明
4. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可

# Spring Cloud Alibaba


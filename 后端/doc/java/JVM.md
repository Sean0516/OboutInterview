



![JVM](https://gitee.com/Sean0516/image/raw/master/img/JVM.png)



![image-20210805172149574](https://gitee.com/Sean0516/image/raw/master/img/image-20210805172149574.png)

## 概念



### JRE JDK JVM 以及JIT 之间有什么不同

JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性

### safepoint是什么

当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的

如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长



## 内存区域

![image-20210630140457284](http://qvi33264o.hn-bkt.clouddn.com/img/image-20210630140457284.png)

### 程序计数器（线程私有）

一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。

正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。

这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域

### 虚拟机栈（线程私有）

是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分（DispatchException）。 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

### 本地方法区(线程私有)

本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一

### 堆（Heap-线程共享） -运行时数据区

是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代

### 方法区/永久代（线程共享）

即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据.HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小) 。

运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池 （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行

### Java 中堆和栈有什么区别

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享

###### 栈

在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用

###### 堆

堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称

## 垃圾回收算法

### 概况 

1. 什么是垃圾
2. 怎么找到垃圾
3. 垃圾回收算法
4. 垃圾回收器
5. 调优

### 什么是垃圾

​	没有任何引用指向的一个对象或者多个对象

### 如何判断对象可以被回收

1. 引用计数法

   在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。

   所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收

   引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法

2. 可达性分析

   为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收  
   
   #### 可以作为 GC Roots的根的对象  
   
   1. 虚拟机栈中引用的对象
   2. 方法区中静态变量属性引用的对象
   3. 方法区中常量引用的对象
   4. JNI引用的对象

### 垃圾回收算法

- 标记清除算法

  最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。  该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题

- 复制算法（copying）

  为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉

  这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话， Copying算法的效率会大大降低    （算法进行改进。将内存划分为 8:1:1 ） 较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区

- 标记整理算法(Mark-Compact)

  结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象

- 分代收集算法

  分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，没有额外的空间进行分配担保，所以可以采用标记--整理和标记-清除   新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以采用复制算法
  
- 三色标记算法 （漏标   ---垃圾泄漏）

- ![image-20211019180727209](https://gitee.com/Sean0516/image/raw/master/img/image-20211019180727209.png)

  使用黑白灰三种颜色进行标记在·  CMS 在对象头的markword 中进行颜色标记 

  黑色   自己已经被标记，fieled 都标记完成

  灰  自己标记完成，还没来记得急标记 fields

  白色  未标记的对象 
  
  关于漏标的情况，CMS 使用写屏障来解决。 例如 在A.x=D 的时候，如果A 是黑色，D 是白色，标记A 为灰  （但是还是会存在漏标的情况）
  
  

### 新生代与复制算法

目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中

### 老年代与标记复制算法

因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存

## 分代算法

### 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区

###### Eden 区

Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收

###### Servivor From

上一次 GC 的幸存者，作为这一次 GC 的被扫描者

###### Servivor To

保留了一次 MinorGC 过程中的幸存者

###### MinorGC 的过程（复制->清空->互换）

1. 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）
2. 然后，清空 Eden 和 ServicorFrom 中的对象
3. 最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区

### 老年代

   主要存放应用程序中生命周期长的内存对象。
   老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

   MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 ajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。

   

### 永久代 （永久代必须设置大小限制）与 元数据（JAVA8）

指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常

字符串常量池  1.7 --永久代  1.8 堆

在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。

### 新生代、老年代、持久代都存储哪些东西

###### 新生代

方法中new 一个对象，就会先进入新生代

###### 老年代

1. 新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中
2. 大对象一般直接放入老年代
3. 当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代

###### 永久代

主要存放 Class 和 Meta（元数据）的信息

![image-20210805172857989](https://gitee.com/Sean0516/image/raw/master/img/image-20210805172857989.png)

### 永久代中是否回发生垃圾回收

垃圾回收不会发生在永代，如果永久代满了或者超过了临界值，会触发 Full  GC   Java 8 中已经移除了永久代，新加了一个叫做元数据区的native 内存区

### Full GC Major GC Minor GC 之间的区别

###### Minor GC 

新生代空间的垃圾回收

###### Major GC 

老年代垃圾回收 ，出现MajorGC 通常会出现至少一次的Minor GC

###### Full GC 

正对整个新生代 老年代  元空间 的全局范围GC

### 什么时候会触发FullGC 

1. 老年代空间不足

   老年代只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space

2. 调用System.gc时，系统建议执行Full GC，但是不必然执行

3. 方法区空间不足

4. 通过Minor GC后进入老年代的平均大小大于老年代的剩余空间



## 对象

### 对象是怎么从年轻代进入老年代的

1. 如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的
2. 动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。
3. 分配担保。当 Survivor 空间不够的时候，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配
4. 超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配



### 对象分配规则

1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC、

### Java对象创建过程 （半初始化）

1. 虚拟机遇到一个new 指令，首先将去检查整个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用的类是否已经被加载--解析--初始化
2. 如果类已经被加载，那么进行第三步。 如果没有被加载，则需要先进行类的加载
3. 类加载通过后，进行新生对象的内存分配 （对象生成需要的内存大小在类加载完成后就可以完全确定）
4. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”
5. 空间申请完毕后，JVM 需要将内存的空间都初始化为0 值，如果使用TLAB ，就可以在TLAB 分配的时候进行该进行的工作
6. 对对象头进行必要设置
7. 完成上面的步骤之后，从JVM 来看，一个对象基本完成了， 但是从Java程序代码来看，对象创建才刚刚开始，需要执行 init 方法，按照程序中设定的初始化操作初始化。 

### DCL 单例（Double Check Lock） 到底需不需要volatile

需要，因为需要防止指令重排序  。 第一个线程在半初始化的时候，发生了指令重排序， 线程二 在进行判断时，发现线程已经初始了，但是实际上获取到的是半初始化状态的对象

### 简述Java的对象结构（存储布局）

Java对象由三个部分组成：对象头、实例数据、对齐填充。

1. 对象头由两部分组成 
   1. markword   存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit） 8 字节
   2. 第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。 4 字节
2. 实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）
3. 对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐

### 数组在内存中的存储布局

 和对象一样，只是多了数组长度 4 字节

### 对象怎么定位

1. 句柄方式 

   1. 实例数据指针 
   2. 类型数据指针

   方便GC ，在进行GC 复制的时候，不需要

2. 直接指针 （hotspot ）

   1. 类型数据指针

### 一个Object 对象占多少字节

16 个 

1. 对象头 8 个
2. 指针 4 个字节
3. 对齐 4 个字节

### Class 实例在 方法区 还是在 堆 

​	![image-20211022092428710](https://gitee.com/Sean0516/image/raw/master/img/image-20211022092428710.png)



## 垃圾收集器

### GC 垃圾收集器

![image-20210630141113554](http://qvi33264o.hn-bkt.clouddn.com/img/image-20210630141113554.png)

##### 年轻代

- Serial 垃圾收集器（单线程、 复制算法 ，年轻代）

  Serial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它在进行垃圾收集时，会暂停所有的工作进程，用一个线程去完成GC工作

  新生代采用复制算法 ， 老年代采用标记-整理算法 

  特点：简单高效，适合jvm管理内存不大的情况（十兆到百兆）

- ParNew 垃圾收集器（Serial+多线程） 配合CMS 一起

  ParNew收集器其实是Serial的多线程版本，回收策略完全一样，但是他们又有着不同 。所以它配合多核心的cpu效果更好，如果是一个cpu，他俩效果就差不多。（可用-XX:ParallelGCThreads参数控制GC线程数）

Parallel Scavenge  并行回收

##### 老年代

- CMS （三色标记） Incremental update  通过写屏障来解决漏标的情况 

  ![image-20211110205908752](https://gitee.com/Sean0516/image/raw/master/img/image-20211110205908752.png)

  CMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器,虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao),又称多并发低暂停的收集器

  它是基于标记-清除算法实现的。整个过程分4个步骤
  
  1.  初始标记(CMS initial mark):仅只标记一下GC Roots能直接关联到的对象, 速度很快
  2.  并发标记(CMS concurrent mark: GC Roots Tracing过程)
  3.  重新标记(CMS remark):修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
  4.  并发清除(CMS concurrent sweep: 已死对象将会就地释放)

  初始标记、重新标记需要STW(stop the world 即：挂起用户线程)操作。因为最耗时的操作是并发标记和并发清除。所以总体上我们认为CMS的GC与用户线程是并发运行的

  ###### 优点 

  并发收集、低停顿

  ###### 缺点
  
  1. CMS默认启动的回收线程数=(CPU数目+3)*4  当CPU数>4时, GC线程最多占用不超过25%的CPU资源, 但是当CPU数<=4时, GC线程可能就会过多
     的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低
  2. 无法清除浮动垃圾（GC运行到并发清除阶段时用户线程产生的垃圾），因为用户线程是需要内存的，如果浮动垃圾施放不及时，很可能就造成内存溢出，所以CMS不能像别的垃圾收集器那样等老年代几乎满了才触发，CMS提供了参数 -XX:CMSInitiatingOccupancyFraction 来设置GC触发百分比(1.6后默认92%),当然我们还得设置启用该策略 -XX:+UseCMSInitiatingOccupancyOnly
  3. 因为CMS采用标记-清除算法，所以可能会带来很多的碎片，如果碎片太多没有清理，jvm会因为无法分配大对象内存而触发GC，因此CMS提供了 -XX:+UseCMSCompactAtFullCollection 参数，它会在GC执行完后接着进行碎片整理，但是又会有个问题，碎片整理不能并发，所以必须单线程去处理，所以如果每次GC完都整理用户线程stop的时间累积会很长，所以XX:CMSFullGCsBeforeCompaction 参数设置隔几次GC进行一次碎片整理
  
- G1  （逻辑分代， 物理不分代） 三色标记  +SATB

  ![image-20211110210000054](https://gitee.com/Sean0516/image/raw/master/img/image-20211110210000054.png)

  

  ##### SATB  snapshot at  the  beginning 

  在起始的时候做一个快照，在B-> D 消失时，需要把这个引用推到GC 的堆栈，保证D 还能被GC 扫描到，只用扫描那些Region  引用到D 这个Region 

  

  G1最大的特点是引入分区的思路，弱化分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷

  因为每个区都有Eden、Survivor、Old代，所以在G1中，不需要对整个Eden等代进行回收，而是寻找可回收对象比较多的区，然后进行回收（虽然也需要STW操作，但是花费的时间是很少的），保证高效率

  ###### 新生代收集

  G1的新生代收集跟ParNew类似，如果存活时间超过某个阈值，就会被转移到S/O区。年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域的大小

  ###### 老年代收集

  1. 初始标记 (Initial Mark: Stop the World Event)

     在G1中, 该操作附着一次年轻代GC, 以标记Survivor中有可能引用到老年代对象的Regions

  2. 扫描根区域 (Root Region Scanning: 与应用程序并发执行)  

     扫描Survivor中能够引用到老年代的references. 但必须在Minor GC触发前执行完

  3. 并发标记 (Concurrent Marking : 与应用程序并发执行)
     在整个堆中查找存活对象, 但该阶段可能会被Minor GC中断

  4. 重新标记 (Remark : Stop the World Event)
     完成堆内存中存活对象的标记. 使用snapshot-at-the-beginning(SATB, 起始快照)算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度).

  5. 清理 (Cleanup : Stop the World Event and Concurrent)
     在含有存活对象和完全空闲的区域上进行统计(STW)、擦除Remembered Sets(使用RememberedSet来避免扫描全堆，每个区都有对应一个Set用来记录引用信息、读写操作记录)(STW)、重置空regions并将他们返还给空闲列表(free list)(Concurrent)

- ZGC （逻辑物理都不分代）

## 类加载机制

### JVM 类加载机制 (加载-链接-初始化)

类加载机制，是指虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型

JVM 类加载机制分为五个部分： 加载 ，验证，准备，解析， 初始化

#### 加载

加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）  在这一阶段，将完成以下三件事：

1. 通过一个类的全限定名获取该类的二进制流
2. 将该二进制流中的静态存储结构转换为方法去进行时数据结构
3. 在内存中生成该类的Class 对象，作为该类的数据访问入库

#### 链接

###### 验证

这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，该阶段主要完成以下四种验证

1. 文件格式验证： 验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型
2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等
3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等
4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行

###### 准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中

```java
public static int value=123; //在准备阶段 value 初始值为 0 。在初始化阶段才会变为 123 
```

###### 解析

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后

#### 初始化

初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码

初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法



### JVM 加载Class 文件的原理机制

类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中

类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName()方法来把所需的类加载到 JVM 中

## 类加载器



虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类， JVM 提供了4 种类加载器：

###### 启动类加载器(Bootstrap ClassLoader)

负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。

###### 扩展类加载器(Extension ClassLoader)

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

###### 应用程序类加载器(Application ClassLoader)：

负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。

###### 用户自定义类加载器

通过继承 java.lang.ClassLoader 类的方式实现

![image-20210630142521914](http://qvi33264o.hn-bkt.clouddn.com/img/image-20210630142521914.png)

### 双亲委派机制

当收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。

采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象

![image-20210630142606545](http://qvi33264o.hn-bkt.clouddn.com/img/image-20210630142606545.png)

### 为什么要使用双亲委派机制

java虚拟机只会在不同的类的类名相同且加载该类的加载器均相同的情况下才会判定这是一个类。如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。

双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。

没有双亲委派模型，让所有类加载器自行加载的话，假如用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，系统就会出现多个不同的Object类，


### 自定义类加载器

  重写自己的findClass方法

## JVM 调优

### jvm 的参数 

1. 标准  -开头  所有的Hotspot 都支持  java  -version 
2. 非标准  -X 开头，特定版本支持  java -Xmx  -Xms
3. 不稳定 -XX 开头 ，下个版本可能取消

### 你知道哪些JVM性能调优

设定堆内存大小   -Xmx：堆内存最大限制。 -Xms 堆内存的初始大小 为什么 Xmx和Xms  一样大 ，是为了避免扩容 等价  -XX:InitialHeapSize  -XX:MaxHeapSize

-Xss  设置单个线程栈的大小  默认为512k ----1024k

-XX:+printGC  开启打印GC信息

-XX:-printGC  关闭打印GC信息

-XX：属性key=属性值 value

-XX:MatespaceSize=1024m 设置元空间大小 （理论来说，元空间受本地内存影响）

设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代
-XX:NewSize：新生代大小
-XX:NewRatio 新生代和老生代占比
-XX:SurvivorRatio：Eden 区和survivor空间的占比
设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC

### JVM 调优步骤

1. 熟悉业务场景
2. 选择合理的垃圾收集器
3. 计算 内存需求
4. 设置年轻代老年代大小
5. 设置日志参数
6. 压力测试
7. 分析日志
8. 调整参数

### OOM 异常排查

1. 使用top 查看服务器系统状态 
2. ps - aux | grep java 找出当前java 进程的pid
3. jstat  -gcutil pid interval 查看当前GC 状态
4. jmap  -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象
5. jmap -dump:format=b file= 文件名 [pid] 生成dump 文件
6. 使用性能分析工具对 dump 文件进行分析

4. 

### OOM你遇到过哪些情况，SOF你遇到过哪些情况

1. OutOfMemoryError异常
2. 虚拟机栈和本地方法栈溢出
3. 运行时常量池溢出
4. 方法区溢出
5. 堆栈溢出StackOverflow

### 哪些手段用来排查内存溢出

使用jstat命令，发现Old区在一直增长。我使用jmap命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 guava的Cache，并设置了弱引用，故障就消失了

### 生产上如何配置垃圾收集器的



### Linux 上查找哪个线程使用的 CPU 时间最长

1. 使用top 命令，然后使按下 shift + p 查找出cpu 使用率最高的 pid
2. 根据第一步拿到的pid  使用命令 top -H -p pid  然后按下 shift +p 查找cpu 利用率最高的线程
3. 将获取的pid 线程转换为 16 进制  printf '%x\n'  pid
4. 使用 jstack pid > /tmp/d.dat 将进程信息打印输出
5. 编辑 dat 文件，查找线程号对应的信息

### GC 日志的设置

![image-20211019174514053](https://gitee.com/Sean0516/image/raw/master/img/image-20211019174514053.png)



### JVM 调优案例

jstak pid  打印线程栈信息  ，检测死锁 

jinfo  pid 打印程序虚拟机的信息

jstat - gc  pid 显示GC 信息

jmap  -histo   pid  | head -20    查询那个对象占用最多  

##### jmap 执行期间会对进程产生很大影响 。升值卡顿 (MAT 分析，java visual  ,jprofile)

1. 高可用 ，可以停止一台机器
2. 设置参数 HeapDumpOnOutOfMemoryError  （不是很专业，因为有很多监控）
3. 测试环境
4. 在线定位 使用 arthas 工具



### arthas 工具

jvm 显示虚拟机的信息 

dashboard   

thread 显示所有的线程  类是 jstack    thread | grep main    thread -b 显示死锁的线程

sc 

sm  查找方法 

trace  追踪方法执行的时间

heapdump  --live   存储路径   

jad  反编译代码 


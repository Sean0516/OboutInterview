# 集合

![image-20210805173935482](https://gitee.com/Sean0516/image/raw/master/img/image-20210805173935482.png)

![image-20210805173917414](https://gitee.com/Sean0516/image/raw/master/img/image-20210805173917414.png)

### List Map Set 之间的区别

- List 存储一组不唯一 ，有序的对象
- Set 不允许重复的集合，不会有多个元素引用相同的对象
- Map  使用键值对存储，Map 会维护与Key 有关联的值，两个key 可以引用相同的对象。 但是key 不能重复。

### ArrayList 

ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔， 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。 当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除

### ArrayList 源码

#### 字段属性

```java
    // 集合默认大小
    private static final int DEFAULT_CAPACITY = 10;
    // 空的数组实例
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    // 存储array list 集合的元素 数据存放在 Object 数组中
    transient Object[] elementData; // non-private to simplify nested class access
    // 集合的长度
    private int size;
	// 提供快速失败行为
	protected transient int modCount = 0;
```

#### 构造函数

```java
    // 无参构造函数将创建一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA 声明的数组，初始化容量为0
    // 因此根据默认构造函数创建的集合，ArrayList list = new ArrayList()；此时集合长度是0
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```

#### add(E e)  方法

1. 添加元素是，确认集合大小
2. 计算数组的添加元素后的最小容量
3. 比较添加元素后的最小容量和当前数组的长度 ，判断是否需要扩容
4. 如果需要扩容则扩容 
5. 然后将数据放入数组中

```java
    public boolean add(E e) {
        // 在添加元素之前，首先要确定集合的大小
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // 将数据放入数组中
        elementData[size++] = e;
        return true;
    }

// 计算数组的添加元素后的最小容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 如果数组为空，则从size + 1 的值和默认值10 中取最大值
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
//         返回默认值
        return minCapacity;
    }

    private void ensureExplicitCapacity(int minCapacity) {
        // modCount  +1 是给迭代器使用，在并发操作被修改时，提供快速失败行为
        modCount++;

        // 计算最小的容量是否大于当前数组长度，大于则调用grow 方法进行扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
```

#### grow 方法

1. 获取容器的原始容量
2. 获取新容量  新容量=old容量+ (old容量>>1 ) 将新容量更新为old容量的1.5 倍 需要注意的是 (在 jdk 1.6 时 ，扩容为 1.5+1)  .之所以使用位运算符。主要是因为位运算符比普通运算符的运算要块很多，因为程序仅仅移动了一下， 不需要计算，这样提高了效率，节省了资源
3. 检查扩容后的容量是否大于最小需要容量 ，若扩容后的容量仍然小于最小需要容量，则把最小需要容量当作数组的新容量
4. 比较新容量的值和 MAX_ARRAY_SIZE 的大小 进入 hugeCapacity 方法。 来决定容器的最大值。 主要是分两种情况 ，若最小需要容量大需要 MAX_ARRAY_SIZE  则 将Integer.MAX_VAKUE 作为新数组的大小。 若小，则将MAX_ARRAY_SIZE  作为新数组的容量

```java
    private void grow(int minCapacity) {
        // 获取当前数组的原始长度
        int oldCapacity = elementData.length;
        // 根据原始长度计算出新的长度 （原始长度+ 原始长度的0.5） 新数组长度为原始长度的1.5 倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            // 如果计算的新长度仍然小于最小长度，则使用最小容量长度作为新的长度
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 使用copyOf 方法，将原始数组拷贝到新容量的数组中（拷贝引用）
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

#### remove (int index )方法

```java
public E remove(int index) {
    // 判断给定索引的范围是否超过集合大小
    rangeCheck(index);

    modCount++;
    //  返回需要删除的值
    E oldValue = elementData(index);
    //  计算需要移动的数量
    int numMoved = size - index - 1;
    if (numMoved > 0)
        // 对数组进行自身拷贝
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    //设置为Null用于垃圾回收
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

#### remove（Object o）方法

删除第一次出现的该元素。然后通过System.arraycopy进行数组自身拷贝

#### set(index , element)

```java
    public E set(int index, E element) {
        rangeCheck(index);

        E oldValue = elementData(index);
        // 将指定index 的元素替换为element,并返回老元素
        elementData[index] = element;
        return oldValue;
    }	
```

#### 迭代器 通过内部类 Itr实现



```java
private class Itr implements Iterator<E> {
        int cursor;       // 游标 ，下一个需要返回的元素的索引
        int lastRet = -1; //  返回最后一个元素的索引，如果没有 返回-1
        int expectedModCount = modCount;    
Itr() {}
    // 通过游标判断是否还有下一个元素
    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        // 迭代器在进行元素迭代时，同时增加和删除操作会抛出异常
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet; // 游标指向删除元素的位置
            lastRet = -1; // lastRet 恢复默认值 -1
            // expectedModCount 和 modCount 同步，因为在进行add 和remove 时, modCount 会加1
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    final void checkForComodification() {
        // 不能在迭代器进行元素迭代时进行增加和删除操作。否证会抛出异常
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
```

#### 迭代器ListIterator

能实现一边遍历，一边进行新增或删除操作

```java
private class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor - 1;
        }

        @SuppressWarnings("unchecked")
        public E previous() {
            checkForComodification();
            int i = cursor - 1;
            if (i < 0)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i;
            return (E) elementData[lastRet = i];
        }

        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.set(lastRet, e);
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
		// 添加元素
        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
```



### Vector（ 数组实现、 线程同步）

Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢

### LinkList

LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用

### Set 

Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素， 值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号） 判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法

### HashSet

哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素

### Tree Set

1. TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。
2. Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。
3. 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序
4. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数



### HashMap (数组+ 链表+ 红黑树)

HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。 HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。

在 Java8 中， 当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)



大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

1.  capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
2.  loadFactor：负载因子，默认为 0.75
3.  threshold：扩容的阈值，等于 capacity * loadFactor

![](http://qvi33264o.hn-bkt.clouddn.com/img/hashmap.png)

### HashMap 的实现原理

HashMap基于Hash算法，我们通过put(key,value)存储，get(key)来获取。当传入key时，HashMap会根据key.hashCode()计算出hash值，根据hash值将value保存在bucket里。当计算出的hash值相同时怎么办呢，我们称之为Hash冲突，HashMap的做法是用链表和红黑树存储相同hash值的value。当Hash冲突的个数比较少时，使用链表，否则使用红黑树

#### 常用方法

###### 确认哈希桶数组索引位置

不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):

```java
方法一：
static final int hash(Object key) { //jdk1.8 & jdk1.7
int h;
// h = key.hashCode() 为第一步 取hashCode值
// h ^ (h >>> 16) 为第二步 高位参与运算
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
方法二：
static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的
return h & (length-1); //第三步 取模运算
}
```

这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算

对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处

这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率

![image-20210812160333690](https://gitee.com/Sean0516/image/raw/master/img/image-20210812160333690.png)

###### put 操作的大致思路为

1. 对key的hashCode()做hash，然后再计算index;
2. 如果数组中没有值，则直接插入；
3. 如果数组中有值，则判断key 是否存在，存在则覆盖value ， 不存在则表示出现了hash冲突，判断是以链表还是以红黑树存放数据；
4. 如果hash 冲突 导致链表过长(大于等于TREEIFY_THRESHOLD 一般是8 )，就把链表转换成红黑树；
5. 如果节点已经存在就替换old value(保证key的唯一性)
6. 插入成功之后， 如果数组长度超过了阈值 ( 当前长度  >     （负载因子 0.75 ）load factor  *current capacity （当前数组容量）)，就要resize （调整table 数组的大小）

在Java 8以前，每次产生hash冲突，就将记录追加到链表后面，然后通过遍历链表来查找。如果某个链表中记录过大，每次遍历的数据就越多，效率也就很低，复杂度为O(n)；
在Java 8中，加入了一个常量TREEIFY_THRESHOLD=8，如果某个链表中的记录大于这个常量的话，HashMap会动态的使用一个专门的treemap实现来替换掉它。这样复杂度是O(logn)，比链表的O(n)会好很多。

###### get 操作

1. bucket里的第一个节点，直接命中；
2. 如果有冲突，则通过key.equals(k)去查找对应的entry
3. 若为树，则在树中通过key.equals(k)查找，O(logn)；
4. 若为链表，则在链表中通过key.equals(k)查找，O(n)。

###### 扩容resize

扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶

```java
1 final Node<K,V>[] resize() {
2 Node<K,V>[] oldTab = table;
3 int oldCap = (oldTab == null) ? 0 : oldTab.length;
4 int oldThr = threshold;
5 int newCap, newThr = 0;
6 if (oldCap > 0) {
7 // 超过最大值就不再扩充了，就只好随你碰撞去吧
8 if (oldCap >= MAXIMUM_CAPACITY) {
9 threshold = Integer.MAX_VALUE;
10 return oldTab;
11 }
12 // 没超过最大值，就扩充为原来的2倍
13 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
14 oldCap >= DEFAULT_INITIAL_CAPACITY)
15 newThr = oldThr << 1; // double threshold
16 }
17 else if (oldThr > 0) // initial capacity was placed in threshold
18 newCap = oldThr;
19 else { // zero initial threshold signifies using defaults
20 newCap = DEFAULT_INITIAL_CAPACITY;
21 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
22 }
23 // 计算新的resize上限
24 if (newThr == 0) {
25
26 float ft = (float)newCap * loadFactor;
27 newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
28 (int)ft : Integer.MAX_VALUE);
29 }
30 threshold = newThr;
31 @SuppressWarnings({"rawtypes"，"unchecked"})
32 Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
33 table = newTab;
34 if (oldTab != null) {
35 // 把每个bucket都移动到新的buckets中
36 for (int j = 0; j < oldCap; ++j) {
37 Node<K,V> e;
38 if ((e = oldTab[j]) != null) {
39 oldTab[j] = null;
40 if (e.next == null)
41 newTab[e.hash & (newCap - 1)] = e;
42 else if (e instanceof TreeNode)
43 ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
44 else { // 链表优化重hash的代码块
45 Node<K,V> loHead = null, loTail = null;
46 Node<K,V> hiHead = null, hiTail = null;
47 Node<K,V> next;
48 do {
49 next = e.next;
50 // 原索引
51 if ((e.hash & oldCap) == 0) {
52 if (loTail == null)
53 loHead = e;
54 else
55 loTail.next = e;
56 loTail = e;
57 }
58 // 原索引+oldCap
59 else {
60 if (hiTail == null)
61 hiHead = e;
62 else
63 hiTail.next = e;
64 hiTail = e;
65 }
66 } while ((e = next) != null);
67 // 原索引放到bucket里
68 if (loTail != null) {
69 loTail.next = null;
70 newTab[j] = loHead;
71 }
72 // 原索引+oldCap放到bucket里
73 if (hiTail != null) {
74 hiTail.next = null;
75 newTab[j + oldCap] = hiHead;
76 }
77 }
78 }
79 }
80 }
81 return newTab;
82 }
```





### ConcurrentHashMap的扩容机制

   结构和上面一致 。都使用了数组+ 链表+ 红黑树
1.7 

1. 基于segment 分段锁实现
2. 每个segment 相对于一个小型的hashmap
3. 每个segment 内部会进行扩容，和hashmap 的扩容逻辑类似
4. 先生成新的数组，然后转移元素到新的数组中
5. 扩容的判断也是每个segment 内部单独判断，判断是否超过阈值

1.8

1. 当某个线程进行put时，如果发现正在进行扩容，那么该线程一起进行扩容
2. 如果某个线程put ，发现没有进行扩容时，则put 数据，然后判断是否超过阈值，超过则进行扩容
3. 支持多个线程 同时扩容
4. 扩容前，也先生成一个新的数组
5. 在转移元素时，先将原数组进行分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组元素转移工作



### HashTable（线程安全）

Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap， Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换

### TreeMap（可排序）

TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时， key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常

### TreeMap 的实现原理

TreeMap是一个通过红黑树实现有序的key-value集合。
TreeMap继承AbstractMap，也即实现了Map，它是一个Map集合
TreeMap实现了NavigableMap接口，它支持一系列的导航方法，
TreeMap实现了Cloneable接口，它可以被克隆
TreeMap本质是Red-Black Tree，它包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。Entry节点根据根据Key排序，包含的内容是value。Entry中key比较大小是根据比较器comparator来进行判断的。size是红黑树的节点个数

### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么

Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响

java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常

### ArrayList,Vector, LinkedList 的存储性能和特性

ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数
据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组
元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全）。通常性能上较 ArrayList 差

LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快

ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势

### Hashmap 什么时候进行扩容呢

当 hashmap 中的元素个数超过数组大小 loadFactor 时，就会进行数组扩容loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当hashmap 中元素个数超过 16 0.75=12 的时候，就把数组的大小扩展为 2 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000),但是理论上来newHashMap(1024) 更合适，不过上面已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 < 1000, 也就是说为了让 0.75 * size > 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了 & 的问题，也避免了 resize的问题

### LinkedHashMap 的实现原理

LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entrybefore,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序

### Iterator 和 ListIterator 的区别是什么

Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。

Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。

ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等

### poll()方法和remove()方法区别?

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是remove() 失败的时候会抛出异常

### 集合框架相关的有哪些最好的实践

1. 根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set
2. 一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整
3. 基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现
4. 总是使用类型安全的泛型，避免在运行时出现ClassCastException
5. 使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()
6. 尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性
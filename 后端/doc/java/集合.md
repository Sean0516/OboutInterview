# 

![image-20210805173935482](https://gitee.com/Sean0516/image/raw/master/img/image-20210805173935482.png)

![image-20210805173917414](https://gitee.com/Sean0516/image/raw/master/img/image-20210805173917414.png)

## 基本概念

### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么

Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响

java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常

### ArrayList,Vector, LinkedList 的存储性能和特性

ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数
据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组
元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全）。通常性能上较 ArrayList 差

LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快

ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势

### Hashmap 什么时候进行扩容呢

当 hashmap 中的元素个数超过数组大小 loadFactor 时，就会进行数组扩容loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当hashmap 中元素个数超过 16 0.75=12 的时候，就把数组的大小扩展为 2 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000),但是理论上来newHashMap(1024) 更合适，不过上面已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 < 1000, 也就是说为了让 0.75 * size > 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了 & 的问题，也避免了 resize的问题

### LinkedHashMap 的实现原理

LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entrybefore,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序

### Iterator 和 ListIterator 的区别是什么

Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。

Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。

ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等

### poll()方法和remove()方法区别?

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是remove() 失败的时候会抛出异常

### 集合框架相关的有哪些最好的实践

1. 根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set
2. 一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整
3. 基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现
4. 总是使用类型安全的泛型，避免在运行时出现ClassCastException
5. 使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()
6. 尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性

### List Map Set 之间的区别

- List 存储一组不唯一 ，有序的对象
- Set 不允许重复的集合，不会有多个元素引用相同的对象
- Map  使用键值对存储，Map 会维护与Key 有关联的值，两个key 可以引用相同的对象。 但是key 不能重复。

## List

### ArrayList 

ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔， 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。 当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除

### ArrayList 源码

#### 字段属性

```java
    // 集合默认大小
    private static final int DEFAULT_CAPACITY = 10;
    // 空的数组实例
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    // 存储array list 集合的元素 数据存放在 Object 数组中
    transient Object[] elementData; // non-private to simplify nested class access
    // 集合的长度
    private int size;
	// 提供快速失败行为
	protected transient int modCount = 0;
```

#### 构造函数

```java
    // 无参构造函数将创建一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA 声明的数组，初始化容量为0
    // 因此根据默认构造函数创建的集合，ArrayList list = new ArrayList()；此时集合长度是0
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```

#### add(E e)  方法

1. 添加元素是，确认集合大小
2. 计算数组的添加元素后的最小容量
3. 比较添加元素后的最小容量和当前数组的长度 ，判断是否需要扩容
4. 如果需要扩容则扩容 
5. 然后将数据放入数组中

```java
    public boolean add(E e) {
        // 在添加元素之前，首先要确定集合的大小
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // 将数据放入数组中
        elementData[size++] = e;
        return true;
    }

// 计算数组的添加元素后的最小容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 如果数组为空，则从size + 1 的值和默认值10 中取最大值
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
//         返回默认值
        return minCapacity;
    }

    private void ensureExplicitCapacity(int minCapacity) {
        // modCount  +1 是给迭代器使用，在并发操作被修改时，提供快速失败行为
        modCount++;

        // 计算最小的容量是否大于当前数组长度，大于则调用grow 方法进行扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
```

#### grow 方法

1. 获取容器的原始容量
2. 获取新容量  新容量=old容量+ (old容量>>1 ) 将新容量更新为old容量的1.5 倍 需要注意的是 (在 jdk 1.6 时 ，扩容为 1.5+1)  .之所以使用位运算符。主要是因为位运算符比普通运算符的运算要块很多，因为程序仅仅移动了一下， 不需要计算，这样提高了效率，节省了资源
3. 检查扩容后的容量是否大于最小需要容量 ，若扩容后的容量仍然小于最小需要容量，则把最小需要容量当作数组的新容量
4. 比较新容量的值和 MAX_ARRAY_SIZE 的大小 进入 hugeCapacity 方法。 来决定容器的最大值。 主要是分两种情况 ，若最小需要容量大需要 MAX_ARRAY_SIZE  则 将Integer.MAX_VAKUE 作为新数组的大小。 若小，则将MAX_ARRAY_SIZE  作为新数组的容量

```java
    private void grow(int minCapacity) {
        // 获取当前数组的原始长度
        int oldCapacity = elementData.length;
        // 根据原始长度计算出新的长度 （原始长度+ 原始长度的0.5） 新数组长度为原始长度的1.5 倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            // 如果计算的新长度仍然小于最小长度，则使用最小容量长度作为新的长度
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 使用copyOf 方法，将原始数组拷贝到新容量的数组中（拷贝引用）
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

#### remove (int index )方法

```java
public E remove(int index) {
    // 判断给定索引的范围是否超过集合大小
    rangeCheck(index);

    modCount++;
    //  返回需要删除的值
    E oldValue = elementData(index);
    //  计算需要移动的数量
    int numMoved = size - index - 1;
    if (numMoved > 0)
        // 对数组进行自身拷贝
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    //设置为Null用于垃圾回收
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

#### remove（Object o）方法

删除第一次出现的该元素。然后通过System.arraycopy进行数组自身拷贝

#### set(index , element)

```java
    public E set(int index, E element) {
        rangeCheck(index);

        E oldValue = elementData(index);
        // 将指定index 的元素替换为element,并返回老元素
        elementData[index] = element;
        return oldValue;
    }	
```

#### 迭代器 通过内部类 Itr实现



```java
private class Itr implements Iterator<E> {
        int cursor;       // 游标 ，下一个需要返回的元素的索引
        int lastRet = -1; //  返回最后一个元素的索引，如果没有 返回-1
        int expectedModCount = modCount;    
Itr() {}
    // 通过游标判断是否还有下一个元素
    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        // 迭代器在进行元素迭代时，同时增加和删除操作会抛出异常
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet; // 游标指向删除元素的位置
            lastRet = -1; // lastRet 恢复默认值 -1
            // expectedModCount 和 modCount 同步，因为在进行add 和remove 时, modCount 会加1
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    final void checkForComodification() {
        // 不能在迭代器进行元素迭代时进行增加和删除操作。否证会抛出异常
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
```

#### 迭代器ListIterator

能实现一边遍历，一边进行新增或删除操作

```java
private class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor - 1;
        }

        @SuppressWarnings("unchecked")
        public E previous() {
            checkForComodification();
            int i = cursor - 1;
            if (i < 0)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i;
            return (E) elementData[lastRet = i];
        }

        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.set(lastRet, e);
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
		// 添加元素
        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
```



### Vector（ 数组实现、 线程同步）

Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢

### LinkList源码

LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用

链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是它并不会按线性的顺序存储数据，而是在每一个节点里存储到下一个节点的指针（Pointer）

#### 字段属性

```java
// 元素个数
transient int size = 0;
// 指向第一个节点的指针
transient Node<E> first;
// 指向最后一个节点的指针
transient Node<E> last;

private static class Node<E> {
        E item; // 数组元素
        Node<E> next; // 指向下一个节点
        Node<E> prev;  // 指向上一个节点
        // 构造函数
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
}
```

#### 添加元素

##### addFirst(E e) 将指定元素添加到链表头

```java
private void linkFirst(E e) {
    // 将头节点赋值给f
    final Node<E> f = first;
    // 构造一个新的节点
    final Node<E> newNode = new Node<>(null, e, f);
    // 将新节点设置为头节点，将原来的头节点f 变为第二个节点
    first = newNode;
    if (f == null) // 如果原理的头节点为空,将这个新的节点设置为尾节点
        last = newNode;
    else
        //将原来的头节点的上一个节点指向新节点
        f.prev = newNode;
    size++; // 节点数+1
    modCount++;
}
```

##### addLast 和 add

```java
    void linkLast(E e) {
        // 将l 设置为为节点
        final Node<E> l = last;
        // 构造新的节点
        final Node<E> newNode = new Node<>(l, e, null);
        // 将尾节点设置为新的节点
        last = newNode;
        if (l == null)
            first = newNode;
        else
            // 将原来为节点的下一个节点，指向新节点
            l.next = newNode;
        size++; // 节点数加 1 
        modCount++;
    }

```

##### add(index,element)

```java
public void add(int index, E element) {
    // 判断索引是否越界
    checkPositionIndex(index);
    // 如果索引等于链表长度，则添加到尾节点
    if (index == size)
        linkLast(element);
    else
        // 获取当前index 的node 节点
        linkBefore(element, node(index));
}
	//查找index 对应的节点，并返回
    Node<E> node(int index) {
        // assert isElementIndex(index);

        if (index < (size >> 1)) {
            Node<E> x = first;
            // 从开始节点到插入节点索引之间的所有节点向后移动一位
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            // 如果插入节点位置在后半部分
            Node<E> x = last;
            // 从最后节点到插入节点索引之间的所有节点向前移动一位
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }

	// 生成新的节点，添加到链表中
  void linkBefore(E e, Node<E> succ) {
        // assert succ != null;
        // 获取当前Index node 的前驱节点
        final Node<E> pred = succ.prev;
        // 构建当前数据新的节点，设置前驱和后继节点
        final Node<E> newNode = new Node<>(pred, e, succ);
        // 设置原始节点的前驱为新的节点
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            // 设置当新节点前驱的后继节点为新节点
            pred.next = newNode;
        size++;
        modCount++;
    }
```

#### 删除元素

##### removeFirst remove 均使用的是unlinkFirst 方法

```java
// 删除第一个节点
private E unlinkFirst(Node<E> f) {
    // assert f == first && f != null;
    // 获	取第一个节点的值
    final E element = f.item;
    // 获取第一个节点的后继节点
    final Node<E> next = f.next;
    // 设置第一个节点的元素，后继为null,便于垃圾回收
    f.item = null;
    f.next = null; // help GC
    // 将后继节点设置为第一个节点
    first = next;
    if (next == null)
        last = null;
    else
        // 将后继节点的前驱节点设置为null
        next.prev = null;
    // 减少元素个数
    size--;
    modCount++;
    return element;
}	
	// 删除尾节点
    private E unlinkLast(Node<E> l) {
        // assert l == last && l != null;
        // 获取最后一个节点的元素
        final E element = l.item;
        // 获取最后一个节点的前驱
        final Node<E> prev = l.prev;
        // 将最后一个节点的元素和前驱设置为null ，方便垃圾回收
        l.item = null;
        l.prev = null; // help GC
        // 将最后一个节点的前驱设置为尾节点，同时将next 设置为空
        last = prev;
        if (prev == null)
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    }
```

##### remove(index) 删除指定位置的元素

```java
E unlink(Node<E> x) {
    // assert x != null;
    // 根据index 获取当前节点，以及当前节点的前驱和后继节点
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;
    // 如果前驱为空，则表示删除第一个元素，将后继节点设置为首节点
    if (prev == null) {
        first = next;
    } else {
        // 将前驱节点的后继节点设置为需要删除的后继节点
        prev.next = next;
        x.prev = null;
    }
    // 如果后继节点为空，则涉资前驱节点为尾节点
    if (next == null) {
        last = prev;
    } else {
        // 不为空，则把后继节点的前驱节点设置为需要删除的节点的前驱节点
        next.prev = prev;
        x.next = null;
    }
    // 将需要删除的节点的前驱，后继和元素设置为Null 方便垃圾回收
    x.item = null;
    size--;
    modCount++;
    return element;
}
```

##### remove(Object o) 通过循环判断，删除第一次出现的元素

```java
public boolean remove(Object o) {
    if (o == null) {
        // 从首节点开始遍历,找到节点元素为null 的节点，删除
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        // 从首节点开始遍历,找到节点元素等于o 的节点，删除 
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
```

#### 迭代器

##### DescendingIterator 倒序打印链表

### Set 

Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素， 值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号） 判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法

### HashSet

哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素

### HashSet 源码

HashSet 本身并没有什么特别的东西，它提供的所有集合核心功能，都是基于HashMap来实现的
HashSet 有如下特点

1. 内部使用HashMap的key存储元素，以此来保证元素不重复
1. HashSet是无序的，因为HashMap的key是无序的
1. HashSet中允许有一个null元素，因为HashMap允许key为null
1. HashSet是非线程安全的



```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable{
    static final long serialVersionUID = -5024744406713321676L;
	// 基于HahMap 实现,由HashMap 的key 的唯一性来保证元素不重复
    private transient HashMap<E,Object> map;
	// 只需要用到HashMap中key唯一的特性，所以value全部使用同一个 Object实例填充，节省内存空间
    private static final Object PRESENT = new Object();
	// 实例化 HashSet 的时候，实际上初始化的是内部的HashMap
    public HashSet() {
        map = new HashMap<>();
    }
    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    }
    // 迭代器
    public Iterator<E> iterator() {
        return map.keySet().iterator();
    }
    // 添加功能，使用HashMap 的put 功能, 传入对应的key 和固定的Object 实例 PRESENT
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }
    public void clear() {
        map.clear();
    }
}
```



### Tree Set

1. TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。
2. Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。
3. 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序
4. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数



## HashMap

### HashMap (数组+ 链表+ 红黑树)

HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。 HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。

在 Java8 中， 当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)

大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

1.  capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
2.  loadFactor：负载因子，默认为 0.75
3.  threshold：扩容的阈值，等于 capacity * loadFactor

![](http://qvi33264o.hn-bkt.clouddn.com/img/hashmap.png)

### HashMap 的实现原理

HashMap基于Hash算法，我们通过put(key,value)存储，get(key)来获取。当传入key时，HashMap会根据key.hashCode()计算出hash值，根据hash值将value保存在bucket里。当计算出的hash值相同时怎么办呢，我们称之为Hash冲突，HashMap的做法是用链表和红黑树存储相同hash值的value。当Hash冲突的个数比较少时，使用链表，否则使用红黑树

JDK 1.8 HashMap 底层采用的是数组，数组中的元素存放在链表或红黑树中。

#### 字段属性

```java
// hashmap 初始容量为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
// map 最大容量

static final int MAXIMUM_CAPACITY = 1 << 30;
// 默认装载因子 主要用于阈值计算

static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 当链表长度大于8 会转为红黑树

static final int TREEIFY_THRESHOLD = 8;
// 当链表长度小于6 又会转为链表
static final int UNTREEIFY_THRESHOLD = 6;
// 当map 中的容量大于这个值时，表中的链表才进行树形话

static final int MIN_TREEIFY_CAPACITY = 64;
// 初始化使用的数组
    transient Node<K,V>[] table;
    transient Set<Map.Entry<K,V>> entrySet;
    // 键值对的数量
    transient int size;
    // 快速失败
   
    transient int modCount;
    // 需要扩容的阈值 capacity * load factor 超过这个值，就进行扩容，扩容后的容量为之前的2倍
    int threshold;

```


#### HashMap 数据存放结构 （单向链表结构）

```java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
//红黑树
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
    }
```







#### 确认哈希桶数组索引位置

1. 取hashCode 值
2. 高位参与运算 h>>>16  （h为hashCode 的值）
3. 取模运算  （n-1） & hash  （n 表示table 的长度）

```java
static final int hash(Object key) {
    int h;
    // 取hashCode 值, 高位参与运算 取模运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// (n - 1) & hash] 取模运算，定位当前hash 在table 中的index
```

这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算

对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处

这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率



![image-20210812160333690](https://gitee.com/Sean0516/image/raw/master/img/image-20210812160333690.png)

#### HashMap put 方法  （putVal）

1. 判断数组table是否为空，为空则执行 resize 进行扩容
2. 根据key 计算hash 获得插入数组索引 i ，如果tab[i] 为空，则创建新节点添加。
3. 如果不为空，则判断tab[i] 的首个元素是否和key 一样，一样则直接覆盖value 。
4. 如果不一样，则判断tab[i]  是否为treeNode 如果是红黑树，则直接在树中插入键值对
5. 遍历table[i] ，判断链表长度是否大于8 ，大于8，则将链表转化为红黑树。如果遍历过程中，发现key 已经存在，则覆盖value
6. 插入成功了，进行容量判断，是否进行扩容

在Java 8以前，每次产生hash冲突，就将记录追加到链表后面，然后通过遍历链表来查找。如果某个链表中记录过大，每次遍历的数据就越多，效率也就很低，复杂度为O(n)；
在Java 8中，加入了一个常量TREEIFY_THRESHOLD=8，如果某个链表中的记录大于这个常量的话，HashMap会动态的使用一个专门的treemap实现来替换掉它。这样复杂度是O(logn)，比链表的O(n)会好很多。

##### 数组上有5个元素，而某个链表上有3个元素，问此HashMap的size是多大  (7 个元素  )

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
    	// 初始化数组 table
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
    

```java
	//  如果数组 table 中不包含键值对节点引用，则创建新的键值对引入,并存放到数组中
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        // 如果键的值和节点的hash 等于链表的第一个键值对节点，则直接将e 指向该键值对
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            // 如果数组的节点为TreeNode ，则使用红黑树的插入方法
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 链表中遍历查找对应的key ，同时统计链表长度，当链表长度大于阈值，则进化为红黑树
            for (int binCount = 0; ; ++binCount) {
                // 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 如果链表长度达到阈值，则进化成红黑树
                        treeifyBin(tab, hash);
                    break;
                }
                //当前链表包含要插入的键值对，终止遍历
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        //判断要插入的键值对是否存在 HashMap 中
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
	//// 键值对数量超过阈值时，则进行扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```



###### get 操作

1. bucket里的第一个节点，直接命中；
2. 如果有冲突，则通过key.equals(k)去查找对应的entry
3. 若为树，则在树中通过key.equals(k)查找，O(logn)；
4. 若为链表，则在链表中通过key.equals(k)查找，O(n)。





###### 扩容resize

扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶

```java
inal Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
    	// 如果 table 不为空，表明已经初始化过了
        if (oldCap > 0) {
            
            // 当 table 容量超过容量最大值，则不再扩容   
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 按旧容量和阈值的2倍计算新容量和阈值的大小
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {              
            // 调用无参构造方法时，桶数组容量为默认容量，
	        // 阈值为默认容量与默认负载因子乘积
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
    	// 创建新的桶数组
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
    // 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```



#### 删除元素

1. 根据key 找到index ，元素在桶中的位置
2. 如果是链表，则遍历链表删除 。 
3. 如果是红黑树，则进行树遍历，删除元素，调整树结构 （当红黑树节点小于6时，会转化为链表）

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {
        // 定位key在桶中的位置
        Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 获取当前的节点的元素
            node = p;
        // 如果当前节点还存在next 节点，则需要在链表和红黑树中查找需要删除的节点
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                // 红黑树中查找
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                // 链表中查找
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }

        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode)
                // 删除红黑树中的节点，并重新构建树结构
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                // 直接删除数组中的元素
                tab[index] = node.next;
            else
                // 删除链表中的元素
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```

#### 获取Map 中对应节点的代码

```java
 final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
     //  定位键值对所在数组中的位置，如果该位置有元素，则获取第一个元素
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            // 如果hash和key都与 第一个元素相同，则第一个元素就是我们要获取的，直接返回
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                //如果 first 是 TreeNode 类型，则调用黑红树查找方法
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                //遍历链表进行查找
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

### LinkedHashMap 源码

#### LinkedHashMap 特点

1. 继承HashMap ，所以和HashMap 的底层数据结构是一样的，都是数组+(链表/红黑树) ，扩容机制也一样
1. 通过双向链表来维护数据。
1. 存储顺序和添加顺序一样。 同时可以根据accessOrder 参数来决定是否在访问时移动元素

#### 字段属性

在 HashMap.Node节点 的基础上增加了 “前继节点” 和 “后继节点” 这种双向链表的功能特性

```java
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
```

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {
    //记录这个 LinkedHashMap容器的 头节点
    transient LinkedHashMap.Entry<K,V> head;
    //记录这个 LinkedHashMap容器的 尾节点
    transient LinkedHashMap.Entry<K,V> tail;
	//是否根据访问 进行排序，true表示按照访问顺序，会把访问过的元素放在链表后面。可通过构造方法进行设置
    final boolean accessOrder;
```

#### 添加元素  为了保证LinkedHashMap的迭代顺序，在添加元素时重写的4种方法

1. newNode（hash，key，value，null）
2. newTreeNode方法
3. afterNodeAccess（e）方法 该方法是在accessOrder = true并且插入的当前节点不等于尾节点时，该方法才会生效
4. afterNodeInsertion（evict）方法 移除最老的首节点

```java
 // 如果数组 table 中不包含键值对节点引用，则创建新的键值对引入,并存放到数组中,同时将创建的节点，存放在链表的尾部
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e); // 初始化一个新的节点
    linkNodeLast(p);  // 将添加的元素设置为链表的尾节点
    return p;
}
// 在添加元素后，将元素存放在链表尾部    
    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> last = tail; // 使用临时变量记录尾节点
        tail = p; // 将尾节点设置为当前插入的节点
        if (last == null)
            head = p; // 如果尾节点为空，则设置插入的节点为头节点
        else {
            p.before = last; // 如果链表不为空，则将插入节点的前驱节点设置为原始尾节点
            last.after = p; // 原始尾节点的后驱设置尾当前插入的节点
        }
    }
```

##### newTreeNode

```java
TreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {
    TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);
    linkNodeLast(p);
    return p;
}
```

##### afterNodeAccess（e） 实现LRU机制

```java
    public V get(Object key) {
        Node<K,V> e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder) // 如果为true 则将访问的元素放到链表尾部
            afterNodeAccess(e);
        return e.value;
    }

void afterNodeAccess(Node<K,V> e) { // 将当前节点放到双向链表的尾部 以实现LRU机制
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) { // 当accessOrder为true 且当前节点不等于尾节点的时候，将last 节点赋值为tail 节点
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;// 记录当前节点的上一个节点和下一个节点
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p; // 设置尾节点尾p
        ++modCount;
    }
```





##### afterNodeInsertion 删除最老的首节点

```java
    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) { // 当重写removeEldestEntry的话，那么将会删除最老的一个元素
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }
```

```java
void afterNodeRemoval(Node<K,V> e) { // 删除某个节点时，为了保证链表还是有序的,那么必须维护其前后节点的关系
    LinkedHashMap.Entry<K,V> p =
        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
    p.before = p.after = null;
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
```





### ConcurrentHashMap的扩容机制

   结构和上面一致 。都使用了数组+ 链表+ 红黑树
1.7 

1. 基于segment 分段锁实现
2. 每个segment 相对于一个小型的hashmap
3. 每个segment 内部会进行扩容，和hashmap 的扩容逻辑类似
4. 先生成新的数组，然后转移元素到新的数组中
5. 扩容的判断也是每个segment 内部单独判断，判断是否超过阈值

1.8

1. 当某个线程进行put时，如果发现正在进行扩容，那么该线程一起进行扩容
2. 如果某个线程put ，发现没有进行扩容时，则put 数据，然后判断是否超过阈值，超过则进行扩容
3. 支持多个线程 同时扩容
4. 扩容前，也先生成一个新的数组
5. 在转移元素时，先将原数组进行分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组元素转移工作

JDK1.7 使用的分段锁机制，其内部类Segment 继承了ReentrantLock ，将容器内的数组划分为多段区域，每个区域对应一把锁 ，但是在数据量庞大的情况下，性能依然不容乐观， 只能通过不断的增加锁来维持并发性能。而JDK1.8 则使用了CAS 乐观锁和synchronized 局部锁处理并发问题， 锁粒度更细，即使数据量恒大也能保证良好的并发性



### ConcurrentHashMap 源码

#### 节点类型

节点类型有五种：Node、TreeBin、TreeNode、ForwardingNode和ReservationNode

![image-20211014164127841](https://gitee.com/Sean0516/image/raw/master/img/image-20211014164127841.png)



在Node 桶中，Node 连接着一个链表，数据被封装成Node 节点以链表的方式存储，在TreeBin 桶中，TreeBin 连接着一个红黑树，真实数据被封装成TreeNode 节点以红黑树的结构存储。TreeBin 指向红黑树的根节点。

##### ForwardingNode

ForwardingNode是一种临时节点，hash值为固定值 -1，在扩容进行中才会出现，相当于一个占位节点。当table中节点数量到达指定的阈值时，ConcurrentHashMap就会进行扩容。扩容时ConcurrentHashMap会新建一个数组nextTable，将原来数组table中的数据迁移到新的数组nextTable中。当table数组的一个hash桶中全部的节点都迁移到了nextTable中，原table数组的桶中会被放置一个ForwardingNode节点

##### ReservationNode

ReservationNode是一个保留节点，hash值为固定值 -3，在ConcurrentHashMap中就相当于一个占位符，不存储实际的数据，正常情况不会出现。在ConcurrentHashMap中，computeIfAbsent和compute这两个函数在加锁时会使用ReservationNode起到占位符的作用

##### treeBin

treeBin是红黑树的顶级节点，hash值为固定值 -1。当桶中的数据以红黑树结构存储的时候，TreeBin作为桶的顶级节点，存储在table中 

使用treeBin主要是为了：

1.  降低treeNode 的复杂度
2.  指定根节点。 可以让在顶级节点加锁的方式实现线程安全



ConcurrentHashMap 和HashMap 的常量和成员变量类似。 主要新增了以下比较重要的参数

#### 字段属性

```java
static final int MOVED     = -1; // 表示正在转移
static final int TREEBIN   = -2; // 表示已经转换成树
static final int RESERVED  = -3; // hash for transient reservations
static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash
transient volatile Node<K,V>[] table;//默认没初始化的数组，用来保存元素
private transient volatile Node<K,V>[] nextTable;//转移的时候用的数组
private transient volatile int sizeCtl; // 参数用途很多
```

##### sizeCtl

sizeCtl的用途比较多，其中负数代表正在进行初始化或者扩容操作。根据情境的不同，sizeCtl有不同的含义及作用，总结起来分为以下四种情况

1. sizeCtl =0 默认值，表示table 初始化时使用默认容量
2. sizeCtl>0   
   1. 如果table未初始化，sizeCtl表示table初始化的容量
   2. table 已经 已经初始化，sizeCtl表示table扩容的阈值。 
3. sizeCtl=-1 表示有线程正在初始化table数组操作。 使用CAS 更新sizeCtl 的值保证只有一个线程执行初始化操作
4. sizeCtl = -(1 + nThreads) 表示有nThreads 个线程在进行扩容操作

 ConcurrentHashMap 的核心就在于其put元素时 利用synchronized局部锁 和 CAS乐观锁机制 大大提升了本集合的并发能力，比JDK7的分段锁性能更强

#### putVal 方法

1. 数组未初始化，初始化table ，然后重新执行插入操作
2. table[i] 数组为空，通过CAS 将数据插入table,插入失败，则重新自旋插入操作
3. table[i]不为空 ，如果正在扩容，则需要先扩容，扩容完毕后，重新开始插入操作
4. 当hash 冲突
   1. 首先对table[i]加锁 ，同时检测table[i] 是否被修改。如果已经被修改，则重新插入操作
   2. 若加锁成功。 判断table[i] 是链表还是红黑树 ，通过hash 值来判断类型 如果 hash >0 则表示链表 

![image-20211014173231657](https://gitee.com/Sean0516/image/raw/master/img/image-20211014173231657.png)

```java
 final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode()); // 计算hash
        int binCount = 0; // 桶中的bin 数量
        for (Node<K,V>[] tab = table;;) { // 自旋插入数据
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0) // 数组为空,初始化数组
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { //table[i]无数据, 使用CAS操作 将 Node键值对 放入对应的数组下标。
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null))) //CAS 失败，自旋
                    break;                   // no lock when adding to empty bin CAS 成功跳出循环
            }
            else if ((fh = f.hash) == MOVED) // 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) { // 对当前Node进行加锁
                    if (tabAt(tab, i) == f) {// 检测数据是否被其他线程修改
                        if (fh >= 0) { // 表示neode 节点是链表
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) { // 元素进行遍历，如果找到了key和key的hash值都一样的节点，则把它的值替换到， 如果没找到的话，则添加在链表的最后面
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) { // key 是否相等，相等则更新节点的值
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null); // 不相等则新建一个node 加入链表中
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) { // 如果是红黑树
                            Node<K,V> p;
                            binCount = 2; // 插入红黑树 binCount等于2
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) { // binCount >0 表示插入成功，同时判断链表是否转换为红黑树
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i); // 链表转换为红黑树
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount); // 插入结束更新元素总数,判断是否需要扩容
        return null;
    }
// 将链表转换为红黑树
 private final void treeifyBin(Node<K,V>[] tab, int index) {
        Node<K,V> b; int n, sc;
        if (tab != null) {
            if ((n = tab.length) < MIN_TREEIFY_CAPACITY) // 如果table 容量小于64 将table扩容2倍
                tryPresize(n << 1);
            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) { // 如果大于64 则进行链表到红黑树的转换
                synchronized (b) {
                    if (tabAt(tab, index) == b) {// 检测是否被其他线程修改
                        TreeNode<K,V> hd = null, tl = null;
                        for (Node<K,V> e = b; e != null; e = e.next) { // 遍历双向链表，创建双向链表
                            TreeNode<K,V> p =
                                new TreeNode<K,V>(e.hash, e.key, e.val,
                                                  null, null); // 将node 节点转换为tree node
                            if ((p.prev = tl) == null)
                                hd = p;
                            else
                                tl.next = p;
                            tl = p;
                        }
                        setTabAt(tab, index, new TreeBin<K,V>(hd)); // 以TreeBin 类型包装双向链表为红黑树，报错TreBin 到table[index] 中
                    }
                }
            }
        }
    }
```

##### initTable

initTable方法使用CAS无锁策略，保证同时只能有一个线程执行初始化table的工作

```java
private final Node<K,V>[] initTable() { // 初始化数组
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) < 0) // 有其他线程进行初始化操作 线程自旋，让出CPU
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // CAS 更新sizeCTL 为-1 成功，表示当前线程进行初始化工作
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc; // 设置sizeCtl 用作扩容的阈值
            }
            break;
        }
    }
    return tab;
}
```

#### replaceNode

![image-20211014173415568](https://gitee.com/Sean0516/image/raw/master/img/image-20211014173415568.png)



##### 流程

根据key 值查找到匹配的键值对 ，如果存在匹配的键值对，将其从table 中删除，最后更新键值对。 如果成功删除，将计数减 1

1. table 为空 table[i] 为空，则表示桶为空，不需要删除，直接返回null
2. table[i] 不为空, table[i] 的节点为ForwardingNode 节点 ，此时table 正在扩容，线程协助数据迁移 。数据迁移完毕后, 线程会重新自旋,进行插入
3. 对node 进行加锁 检测 node 是否被修改，如果没修改，则判断 node 为链表还是红黑树
4. 为链表,遍历查询key 相等的节点是否存在 ,存在则保存旧值,跳出循环,不存在，则返回nul
5. 为红黑树, 从根节点查询key 相等的节点。,如果存在，则保存旧值,并删除节点
6. 键值对删除完毕后，释放同步锁 ，通过addCount 将计数减一

```java
 final V replaceNode(Object key, V value, Object cv) {
        int hash = spread(key.hashCode());// 计算key 的hash 值
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0 ||
                (f = tabAt(tab, i = (n - 1) & hash)) == null) // tab 为空 且 未找到对接的节点 跳出循环
                break;
            else if ((fh = f.hash) == MOVED) // 当前数组正在扩容,先帮助扩容
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                boolean validated = false;
                synchronized (f) {// 对需要删除的节点加锁
                    if (tabAt(tab, i) == f) { // 检测线程是否被修改,防止其他线程的写修改
                        if (fh >= 0) { //判断节点类型 >0 则表示为链表
                            validated = true;
                            for (Node<K,V> e = f, pred = null;;) { // 遍历链表,查找
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    V ev = e.val;
                                    if (cv == null || cv == ev ||
                                        (ev != null && cv.equals(ev))) {
                                        oldVal = ev; // 保存旧值
                                        if (value != null)
                                            e.val = value;
                                        else if (pred != null) // 当前节点e 不是头节点 更新e 前驱节点的后继节点为e 节点的后继节点
                                            pred.next = e.next;
                                        else // e 为头节点 更新table[i] 为头节点的后继节点，将头节点删除
                                            setTabAt(tab, i, e.next);
                                    }
                                    break;
                                }
                                pred = e;
                                if ((e = e.next) == null)
                                    break;
                            }
                        }
                        else if (f instanceof TreeBin) { // 如果为红黑树
                            validated = true;
                            TreeBin<K,V> t = (TreeBin<K,V>)f; // 强制类型转换
                            TreeNode<K,V> r, p;
                            if ((r = t.root) != null &&
                                (p = r.findTreeNode(hash, key, null)) != null) { //红黑树节点不为空 且查询 key 相等的节点
                                V pv = p.val;
                                if (cv == null || cv == pv ||
                                    (pv != null && cv.equals(pv))) {
                                    oldVal = pv; // 保存旧值
                                    if (value != null)
                                        p.val = value;
                                    else if (t.removeTreeNode(p)) //  从红黑树中移除节点
                                        setTabAt(tab, i, untreeify(t.first));
                                }
                            }
                        }
                    }
                }
                if (validated) { // 删除数据成功后,将计数减去 1
                    if (oldVal != null) {
                        if (value == null) // value 不为空,则是为了判断是否为replace 元素
                            addCount(-1L, -1);
                        return oldVal;
                    }
                    break;
                }
            }
        }
        return null;
    }
```

#### get 方法

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode()); // 计算hash 值
    if ((tab = table) != null && (n = tab.length) > 0 && // table 已经初始化
        (e = tabAt(tab, (n - 1) & h)) != null) {  // 定位key 在table的位置
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek))) // 相等访问值
                return e.val;
        }
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null; // 在红黑树中查找 需要加锁查找
        while ((e = e.next) != null) { // 遍历链表查找
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
// TreeBin 的find 方法
  final Node<K,V> find(int h, Object k) {
            if (k != null) {
                for (Node<K,V> e = first; e != null; ) {
                    int s; K ek;
                    if (((s = lockState) & (WAITER|WRITER)) != 0) {
                        if (e.hash == h &&
                            ((ek = e.key) == k || (ek != null && k.equals(ek))))
                            return e;
                        e = e.next;
                    }
                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,
                                                 s + READER)) {
                        TreeNode<K,V> r, p;
                        try {
                            p = ((r = root) == null ? null :
                                 r.findTreeNode(h, k, null));
                        } finally {
                            Thread w;
                            if (U.getAndAddInt(this, LOCKSTATE, -READER) ==
                                (READER|WAITER) && (w = waiter) != null)
                                LockSupport.unpark(w);
                        }
                        return p;
                    }
                }
            }
            return null;
        }
```

##### size 方法

键值对计数时使用了分段锁的思路，计数相关的字段为：baseCount和counterCells数组

counterCells数组为计数数组，属于CounterCell类型的volatile数组，当有并发冲突时，更新计数时会累加到counterCells数组中。CounterCell类比较简单，只有一个value字段，用于保存计数信息

```java
final long sumCount() {// 计算map 中键值对的总数
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) { // 遍历累加 counterCells 中所有数据
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

##### addCount 

用于size 的更新和数组扩容

```java
private final void addCount(long x, int check) { // 更新计数,判断是否需要扩容
    CounterCell[] as; long b, s;
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { // as 为null 说明没发生并发冲突,通过CAS 将计数信息累加到baseCount
            fullAddCount(x, uncontended);  // 未初始化或CAS更新失败, 执行fullAddCount
            return;
        }
        if (check <= 1)
            return;
        s = sumCount();
    }
    if (check >= 0) { // 检测是否需要扩容
        Node<K,V>[] tab, nt; int n, sc;
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt); // 扩容
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
```





#### 扩容和数据迁移 （太复杂，后面理解）

首先是数组扩容，新建一个2倍于原来容量的新数组newTable，这一步需保证只能由一个线程完成。



然后进行数据迁移，把旧数组table中的所有元素重新计算桶的位置后再转移到新数组中 





### HashTable（线程安全）

Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap， Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换

### TreeMap（可排序）

TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时， key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常

### TreeMap 的实现原理

TreeMap是一个通过红黑树实现有序的key-value集合。
TreeMap继承AbstractMap，也即实现了Map，它是一个Map集合
TreeMap实现了NavigableMap接口，它支持一系列的导航方法，
TreeMap实现了Cloneable接口，它可以被克隆
TreeMap本质是Red-Black Tree，它包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。Entry节点根据根据Key排序，包含的内容是value。Entry中key比较大小是根据比较器comparator来进行判断的。size是红黑树的节点个数

